////------------------------------------------------------------------------------
//// <auto-generated>
////     This code was generated by a tool.
////     Runtime Version:4.0.30319.0
////
////     Changes to this file may cause incorrect behavior and will be lost if
////     the code is regenerated.
//// </auto-generated>
////------------------------------------------------------------------------------

//// The file was created by AsyncCodeGenerator.
//// Version: 1.0.1.0
//// Date: Tue, 12 May 2015 16:52:45 GMT
//// Project page: https://github.com/Ne4to/AsyncCodeGenerator
//namespace Assistant
//{
    
    
//    [System.Diagnostics.DebuggerStepThroughAttribute()]
//    internal static class AsyncExtensions
//    {
        
//        /// <summary>
//        /// Starts declining requests for new conversations on the endpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Upon calling the method the endpoint enters the Draining state. In this state new
//        /// conversations are declined while calls on existing conversations continue to be accepted.
//        /// When no outstanding conversations remain, the callback is invoked. Application would normally
//        /// terminate the endpoint after the callback is invoked. However, it is free to terminate the endpoint
//        /// at any time.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the endpoint is not Established or Reestablishing.
//        /// </exception>
//        public static System.Threading.Tasks.Task DrainAsync(this Microsoft.Rtc.Collaboration.ApplicationEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDrain, source.EndDrain, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to verify given pin for the uri.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="uriToVerify">
//        /// The uri for which we need to verify the pin. This can be a global telephone uri, telephone extension or a SIP uri. Cannot be null or empty.
//        /// </param>
//        /// <param name="pin">
//        /// Pin to be verified. Cannot be null or empty.
//        /// </param>
//        /// <param name="options">
//        /// The optional parameters to be used when verifying given pin.
//        /// </param>
//        /// <returns>
//        /// Returns pin owner details.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the
//        ///             parameter is null, empty or invalid sip URI or tel URI.
//        ///             parameter is null or empty.
//        ///             parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the 
//        ///            
//        ///            Endpoint is not in valid state to perform this operation.
//        ///            
//        ///            Pin services uri is not available.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.PinManagement.PinFailureException">
//        /// Thrown when the pin verification for the given uri failed. Applications can use the Reason property to get the failure reason.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.PinManagement.PinVerificationResult> VerifyPinAsync(this Microsoft.Rtc.Collaboration.PinManagement.ApplicationPinServices source, string uriToVerify, string pin, Microsoft.Rtc.Collaboration.PinManagement.VerifyPinOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.PinManagement.PinVerificationResult>.Factory.FromAsync(source.BeginVerifyPin, source.EndVerifyPin, uriToVerify, pin, options, null);
//        }
        
//        /// <summary>
//        /// Establishes an outgoing call using app sharing call specific options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to establish the call.
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.ApplicationSharingCall source, Microsoft.Rtc.Internal.Collaboration.AppSharingCallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, options, null);
//        }
        
//        /// <summary>
//        /// Starts activating the client. Must be the first call in a sharing session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown if unable to activate the client.
//        /// </exception>
//        public static System.Threading.Tasks.Task ActivateAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.ApplicationSharingHost source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginActivate, source.EndActivate, null);
//        }
        
//        /// <summary>
//        /// Starts an asynchronous operation that release control of sharer's desktop.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if there is an outstanding control request.
//        /// </exception>
//        public static System.Threading.Tasks.Task ReleaseControlAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.ApplicationSharingViewer source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginReleaseControl, source.EndReleaseControl, null);
//        }
        
//        /// <summary>
//        /// Starts an asynchronous operation that requests control of sharer's desktop.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if there is an outstanding control request.
//        /// </exception>
//        public static System.Threading.Tasks.Task RequestControlAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.ApplicationSharingViewer source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRequestControl, source.EndRequestControl, null);
//        }
        
//        /// <summary>
//        /// Initiates a call retrival request to the provisioned call park server using
//        /// the given orbit information.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="orbit">
//        /// Orbit information to use retrieve parked call.
//        ///            This parameter value cannot be null.
//        /// </param>
//        /// <param name="options">
//        /// Call establish options to be used when retrieving call from the park server. This parameter value can be null.
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the 
//        ///             parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the 
//        ///             parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the
//        ///            
//        ///            Current call is not in a valid state to initiate an establish operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Collaboration.CallOrbit orbit, Microsoft.Rtc.Collaboration.CallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, orbit, options, null);
//        }
        
//        /// <summary>
//        /// Establishes an outgoing call using audio-video call specific options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to establish the call.
//        /// </param>
//        /// <remarks>
//        /// Applications can use  property to set MCU dial-in options if this call established with a MCU.
//        /// 
//        /// Setting the  property to true is only valid in scenarios where
//        /// the conversation has joined a conference as a trusted application. See .
//        /// 
//        /// An application can establish multiple  instances within the same conversation if that conversation joined the conference as a trusted application.
//        /// In order to establish multiple calls, the application needs to set  to true.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in valid state to perform this operation or does not have valid media provider to bind to or
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, options, null);
//        }
        
//        /// <summary>
//        /// Sends a provisional reliable response with a 183 response code ; also creates an early dialog.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in the incoming state, the remote side does not support reliable provisional response or when early media is already being negotiated.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation is timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishEarlyMediaAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablishEarlyMedia, source.EndEstablishEarlyMedia, null);
//        }
        
//        /// <summary>
//        /// Sends a provisional reliable response with a 183 response code ; will also create an early dialog.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to be send on provisional response. Can be null.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in the incoming state, the remote side does not support reliable provisional response or when early media is already being negotiated.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation is timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishEarlyMediaAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Collaboration.CallProvisionalResponseOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablishEarlyMedia, source.EndEstablishEarlyMedia, options, null);
//        }
        
//        /// <summary>
//        /// Sends a provisional reliable response on the call; will also create an early dialog.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// Response code.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to be send on provisional response. Can be null.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter contains null values.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in the incoming state, the remote side does not support reliable provisional response or when early media is already being negotiated.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation is timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishEarlyMediaAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, int responseCode, Microsoft.Rtc.Collaboration.CallProvisionalResponseOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablishEarlyMedia, source.EndEstablishEarlyMedia, responseCode, options, null);
//        }
        
//        /// <summary>
//        /// Initiates a park request to the provisioned call park server.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Call park options. This parameter value can be null
//        /// </param>
//        /// <remarks>
//        /// When the park operation completes successfully, this call will be terminated. Other calls in the same conversation will
//        /// continue to stay established.
//        /// </remarks>
//        /// <returns>
//        /// Returns the Park message data with orbit number and parsed SIP
//        /// response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in valid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the park request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the park operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object  /// state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related 
//        ///            errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallParkResponseData> ParkAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Collaboration.CallParkOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallParkResponseData>.Factory.FromAsync(source.BeginPark, source.EndPark, options, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to send message to the remote participant of this call.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageType">
//        /// Message type to send.
//        /// </param>
//        /// <param name="contentDescription">
//        /// Content description to send.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to send in the message.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when message type  is not one of
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the content description in parameter  is invalid.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is in an invalid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> SendMessageAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Signaling.MessageType messageType, Microsoft.Rtc.Signaling.ContentDescription contentDescription, Microsoft.Rtc.Collaboration.CallSendMessageRequestOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginSendMessage, source.EndSendMessage, messageType, contentDescription, options, null);
//        }
        
//        /// <summary>
//        /// Initiates an attended transfer request to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="targetUri">
//        /// The transfer target URI.
//        /// </param>
//        /// <remarks>
//        /// In Attended type, the call montiors the success/failure notifications from the remote regarding how the transfer is being carried out.
//        /// If the transfer succeeds, this call is terminated else, the call is not affected.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed successsful SIP response from the transfer operation.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter value is null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the current call is not in a valid state to initiate a transfer operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the transfer request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the transfer operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> TransferAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, string targetUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginTransfer, source.EndTransfer, targetUri, null);
//        }
        
//        /// <summary>
//        /// Initiates a transfer request to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="targetUri">
//        /// The transfer target URI.
//        /// </param>
//        /// <param name="callTransferOptions">
//        /// Call transfer options. This parameter can be null
//        /// </param>
//        /// <remarks>
//        /// Transfer the current call to the given transfer target
//        /// in Attended or Unattended mode.
//        /// In Unattended type, the call is terminated as soon as the transfer request is accepted by the remote participant.
//        /// In Attended type, the call montiors the success/failure notifications from the remote regarding how the transfer is being carried out.
//        /// If the transfer succeeds, this call is terminated else, the call is not affected.
//        /// If the final notification does not arrive within MaximumTransferTime (default is 10 minutes), the transfer is automatically failed.
//        /// If the transfer fails, the call is not terminated.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed successsful SIP response from the transfer operation.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the 
//        ///             value is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the parameter is specified with unsupported headers or
//        ///            is used to override transferor value by any endpoint other 
//        ///            than an Application Endpoint.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the current call is not in a valid state to initiate a transfer operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the transfer request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the transfer operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> TransferAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, string targetUri, Microsoft.Rtc.Collaboration.CallTransferOptions callTransferOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginTransfer, source.EndTransfer, targetUri, callTransferOptions, null);
//        }
        
//        /// <summary>
//        /// Initiates a transfer request to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="callToReplace">
//        /// The call to be replaced.
//        /// </param>
//        /// <remarks>
//        /// Initiates a transfer request to the remote participant of the current call to
//        /// replace another existing call in Attended mode.
//        /// 
//        /// This is a Supervised transfer since the operation involves another call and it waits for
//        /// success/failure notifications from the remote participant regarding how the transfer is
//        /// being carried out at the remote side. When the transfer is completed successfully by the
//        /// existing remote participant, the current call is terminated. If it fails, the call is not affected.
//        /// 
//        /// If callToReplace is passed as the instance of the call initiating the transfer, then this
//        /// would be considered as the self-transfer.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed successsful SIP response from the transfer operation.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the 
//        ///             value is null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the  is 
//        ///            not in the Established state
//        ///            or the current call is not in a valid state to initiate a transfer operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the transfer request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the transfer operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> TransferAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Collaboration.Call callToReplace)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginTransfer, source.EndTransfer, callToReplace, null);
//        }
        
//        /// <summary>
//        /// Initiates a transfer request to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="callToReplace">
//        /// The call to be replaced.
//        /// </param>
//        /// <param name="callTransferOptions">
//        /// Call transfer options. This parameter can be null.
//        /// </param>
//        /// <remarks>
//        /// Initiates a transfer request to the remote participant, of the current call to
//        /// replace another existing call in Attended mode.
//        /// This is a Supervised transfer since the operation involves another call and it waits for
//        /// success/failure notifications from the remote participant regarding how the transfer
//        /// is being carried out at the remote side. When the transfer is successfully completed
//        /// by the existing remote participant, the current call is terminated. If it fails, the call is not affected.
//        /// 
//        /// If callToReplace is passed as the instance of the call initiating the transfer, then this would
//        /// be considered as the self-transfer.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed successsful SIP response from the transfer operation.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the 
//        ///             value is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is specified 
//        ///            with unsupported headers, or is used to override transferor value by any endpoint other 
//        ///            than an Application Endpoint or
//        ///            is of type Unattended transfer.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the  is not in 
//        ///            the Established state
//        ///            or the current call is not in a valid state to initiate a transfer operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the transfer request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the transfer operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> TransferAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall source, Microsoft.Rtc.Collaboration.Call callToReplace, Microsoft.Rtc.Collaboration.CallTransferOptions callTransferOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginTransfer, source.EndTransfer, callToReplace, callTransferOptions, null);
//        }
        
//        /// <summary>
//        /// Applies changes from the specified template.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="template">
//        /// The template to be used as a reference.
//        /// </param>
//        /// <remarks>
//        /// This method cannot be used to change the AudioVideoFlow's hold status.
//        /// Call BeginHold to put the AudioVideoFlow on hold, and BeginRetrieve to unhold.
//        /// The value of the template's HoldType property must be equal to either None or the current
//        /// value of the AudioVideoFlow HoldStatus property. A value of None will not change the
//        /// AudioVideoFlow's hold status.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the AudioVideoFlow is not in the Active state,
//        ///            or when the template has no channels,
//        ///            or when the template's HoldType property is not equal to either None or the AudioVideoFlow's current HoldStatus,
//        ///            or when there is already an asynchronous operation in progress.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the template argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  argument is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task ApplyChangesAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlow source, Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlowTemplate template)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginApplyChanges, source.EndApplyChanges, template, null);
//        }
        
//        /// <summary>
//        /// Applies changes from the specified template.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="template">
//        /// The template to be used as a reference.
//        /// </param>
//        /// <param name="headers">
//        /// The signaling headers.
//        /// </param>
//        /// <remarks>
//        /// This method cannot be used to change the AudioVideoFlow's hold status.
//        /// Call BeginHold to put the AudioVideoFlow on hold, and BeginRetrieve to unhold.
//        /// The value of the template's HoldType property must be equal to either None or the current
//        /// value of the AudioVideoFlow HoldStatus property. A value of None will not change the
//        /// AudioVideoFlow's hold status.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the AudioVideoFlow is not in the Active state,
//        ///            or when the template has no channels,
//        ///            or when the template's HoldType property is not equal to either None or the AudioVideoFlow's current HoldStatus,
//        ///            or when there is already an asynchronous operation in progress.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the template argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  argument is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task ApplyChangesAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlow source, Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlowTemplate template, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> headers)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginApplyChanges, source.EndApplyChanges, template, headers, null);
//        }
        
//        /// <summary>
//        /// Begins to hold the AudioVideoFlow.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="holdType">
//        /// The type of hold to be used.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the AudioVideoFlow is not in the Active state or when there is already an asynchronous operation in progress.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the holdType argument value is not a value in the HoldType enumerated type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  argument is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task HoldAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlow source, Microsoft.Rtc.Collaboration.AudioVideo.HoldType holdType)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginHold, source.EndHold, holdType, null);
//        }
        
//        /// <summary>
//        /// Begins to hold the AudioVideoFlow.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="holdType">
//        /// The type of hold to be used.
//        /// </param>
//        /// <param name="headers">
//        /// The signaling headers.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the AudioVideoFlow is not in the Active state or when there is already an asynchronous operation in progress.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when holdType argument value is None or is not a value in the HoldType enumerated type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  argument is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task HoldAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlow source, Microsoft.Rtc.Collaboration.AudioVideo.HoldType holdType, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> headers)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginHold, source.EndHold, holdType, headers, null);
//        }
        
//        /// <summary>
//        /// Begins to retrieve the AudioVideoFlow.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the AudioVideoFlow is not in the Active state or when there is already an asynchronous operation in progress.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  argument is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task RetrieveAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlow source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRetrieve, source.EndRetrieve, null);
//        }
        
//        /// <summary>
//        /// Begins to retrieve the AudioVideoFlow.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="headers">
//        /// The signaling headers.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the AudioVideoFlow is not in the Active state or when there is already an asynchronous operation in progress.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  argument is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  argument is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task RetrieveAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoFlow source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> headers)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRetrieve, source.EndRetrieve, headers, null);
//        }
        
//        /// <summary>
//        /// Updates routing of outgoing audio to and the incoming audio
//        /// from other endpoints that are connected to the audio-video MCU.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="outgoingRoutes">
//        /// A list of outgoing routes to other endpoints connected to the MCU.
//        /// </param>
//        /// <param name="incomingRoutes">
//        /// A list of incoming audio routes from other endpoints connected to the MCU.
//        /// </param>
//        /// <remarks>
//        /// This method updates the existing routing (outgoing or incoming) that has been setup for a call. If the parent  was established within the audio-video MCU default
//        /// routing, the first call to this method actually removes the parent  from the audio-video MCU default routing and setups up the requested routes.
//        /// Subsequent calls to this method add or remove routes to the ones that have been already established. As an example, if the application already called this method to add an outgoing
//        /// route to endpoint A and then calls the method again to add another route to endpoint B by supplying an outgoing route in , the audio-video MCU will route any media from the parent
//        /// to both A and B.
//        /// 
//        /// The parent  has to be
//        /// connected to a conference as a trusted application.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when both the  and  instances do not include any details.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the call or conference session are not valid. Also thrown when the platform is unable to build
//        ///            a request for the supplied routes. This could happen if all the supplied remote sinks\source have left the 
//        ///            conference before the request was sent.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the MCU fails the routing commands 
//        ///            with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown under other failure conditions.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdateAudioRoutesAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuRouting source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.AudioVideo.OutgoingAudioRoute> outgoingRoutes, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.AudioVideo.IncomingAudioRoute> incomingRoutes)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdateAudioRoutes, source.EndUpdateAudioRoutes, outgoingRoutes, incomingRoutes, null);
//        }
        
//        /// <summary>
//        /// Adds an endpoint to the default MCU routing.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint to add.
//        /// </param>
//        /// <remarks>
//        /// This operation can only be performed by an application that joins the conference as a trusted user.
//        /// 
//        /// Adding an endpoint to the MCU default routing means that the endpoint will receive and send media to the rest of the endpoints
//        /// included in the default routing.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio or if the application did not join the conference
//        ///            as a trusted application.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task AddToDefaultRoutingAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddToDefaultRouting, source.EndAddToDefaultRouting, endpoint, null);
//        }
        
//        /// <summary>
//        /// Adds an endpoint to the default MCU routing.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint to add.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize sending the command.
//        /// </param>
//        /// <remarks>
//        /// This operation can only be performed by an application that joins the conference as a trusted user.
//        /// 
//        /// Adding an endpoint to the MCU default routing means that the endpoint will receive and send media to the rest of the endpoints
//        /// included in the default routing.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio or if the application did not join the conference
//        ///            as a trusted application.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task AddToDefaultRoutingAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint, Microsoft.Rtc.Collaboration.AddToDefaultRoutingOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddToDefaultRouting, source.EndAddToDefaultRouting, endpoint, options, null);
//        }
        
//        /// <summary>
//        /// Requests the Audio-Video MCU to initiate an Audio-Video call to the supplied destination URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The URI of the entity to call.
//        /// </param>
//        /// <remarks>
//        /// The Audio-Video MCU is requested to initiate a call to the destination URI using audio and video as default media types
//        /// if the Conversation does not have either audio and video among its active media types. On the other hand,
//        /// if the Conversation has only audio or video among active its media types, the dial-out request is sent
//        /// with either audio or video only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied destinationUri is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied destinationUri is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task DialOutAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, string destinationUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDialOut, source.EndDialOut, destinationUri, null);
//        }
        
//        /// <summary>
//        /// Requests the Audio-Video MCU to initiate an Audio-Video call to the supplied destination URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The URI of the entity to call.
//        /// </param>
//        /// <param name="audioVideoMcuDialOutOptions">
//        /// Optional parameters to customize the audio-video MCU dial-out request.
//        /// </param>
//        /// <remarks>
//        /// The appearance of the dialed-out to endpoint in the conference roster can be customized by supplying a participant URI and
//        /// display name in the mcuDialOutOptions object. The MCU may not honor the settings if the asserted identity of the dialed-out
//        /// to endpoint was communicated to the MCU during the dial-out operation.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied destinationUri is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied destinationUri is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task DialOutAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, string destinationUri, Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuDialOutOptions audioVideoMcuDialOutOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDialOut, source.EndDialOut, destinationUri, audioVideoMcuDialOutOptions, null);
//        }
        
//        /// <summary>
//        /// Requests the Audio-Video MCU to initiate an Audio-Video call to the supplied destination URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The URI of the entity to call.
//        /// </param>
//        /// <param name="mcuDialOutOptions">
//        /// Optional parameters to customize the dial-out request.
//        /// </param>
//        /// <remarks>
//        /// The appearance of the dialed-out to endpoint in the conference roster can be customized by supplying a participant URI and
//        /// display name in the mcuDialOutOptions object. The MCU may not honor the settings if the asserted identity of the dialed-out
//        /// to endpoint was communicated to the MCU during the dial-out operation.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied destinationUri is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied destinationUri is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task DialOutAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, string destinationUri, Microsoft.Rtc.Collaboration.McuDialOutOptions mcuDialOutOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDialOut, source.EndDialOut, destinationUri, mcuDialOutOptions, null);
//        }
        
//        /// <summary>
//        /// Disables mute all mode on AudioVideoMcuSession if it was already enabled.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// 
//        /// If mute all mode was not enabled previously then this operation completes without any changes to the existing
//        /// mute all mode state on AudioVideoMcuSession.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task DisableMuteAllModeAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDisableMuteAllMode, source.EndDisableMuteAllMode, null);
//        }
        
//        /// <summary>
//        /// Disables mute all on AudioVideoMcuSession if it was already enabled based on given options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to disable mute all mode. Can be null.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// 
//        /// If mute all mode was not enabled previously then this operation completes without any changes to the existing
//        /// mute all state on AudioVideoMcuSession.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task DisableMuteAllModeAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.AudioVideo.DisableMuteAllModeOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDisableMuteAllMode, source.EndDisableMuteAllMode, options, null);
//        }
        
//        /// <summary>
//        /// Enables mute all mode on AudioVideoMcuSession.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// 
//        /// Mute all mode will be enabled but only leaders can unmute themselves.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EnableMuteAllModeAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEnableMuteAllMode, source.EndEnableMuteAllMode, null);
//        }
        
//        /// <summary>
//        /// Enables mute all mode on AudioVideoMcuSession based on given options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters when enabling mute all mode. Can be null.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// 
//        /// Mute all mode will be enabled based on given enable mute all options .
//        /// If the options parameter is not specified mute all mode will be enabled but only leaders can unmute themselves.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EnableMuteAllModeAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.AudioVideo.EnableMuteAllModeOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEnableMuteAllMode, source.EndEnableMuteAllMode, options, null);
//        }
        
//        /// <summary>
//        /// Enables or disables attendance announcements.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="status">
//        /// The new status for attendance announcements.
//        /// </param>
//        /// <remarks>
//        /// This method should be called by conference leaders only.
//        /// 
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if set to
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the command timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the command failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the command failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task ModifyAttendanceAnnouncementsAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.AttendanceAnnouncementsStatus status)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginModifyAttendanceAnnouncements, source.EndModifyAttendanceAnnouncements, status, null);
//        }
        
//        /// <summary>
//        /// Enables or disables attendance announcements.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="status">
//        /// The new status for attendance announcements.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the operation.
//        /// </param>
//        /// <remarks>
//        /// This method should be called by conference leaders only.
//        /// 
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if set to
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the command timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the command failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the command failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task ModifyAttendanceAnnouncementsAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.AttendanceAnnouncementsStatus status, Microsoft.Rtc.Collaboration.AudioVideo.ModifyAttendanceAnnouncementOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginModifyAttendanceAnnouncements, source.EndModifyAttendanceAnnouncements, status, options, null);
//        }
        
//        /// <summary>
//        /// Stops audio coming from the supplied participant endpoint from being sent to the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint for which audio should be muted.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio to mute.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task MuteAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginMute, source.EndMute, endpoint, null);
//        }
        
//        /// <summary>
//        /// Stops audio coming from the supplied participant endpoint from being sent to the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint for which audio should be muted.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the mute operation. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio to mute.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task MuteAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint, Microsoft.Rtc.Collaboration.AudioVideo.MuteOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginMute, source.EndMute, endpoint, options, null);
//        }
        
//        /// <summary>
//        /// Removes an endpoint from the default MCU routing.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint to remove.
//        /// </param>
//        /// <remarks>
//        /// This operation can only be performed by an application that joins the conference as a trusted user.
//        /// 
//        /// Removing an endpoint from the MCU default routing means that the endpoint will no longer receive or send any media to the other endpoints.
//        /// Trusted applications connected to the conference however can further communicate with that endpoint.
//        /// 
//        /// Removing an endpoint from default routing could be useful to render specific services to the endpoint while in the conference. As an example,
//        /// a trusted application can remove the endpoint from the default mix in order to play a help message to that endpoint without disturbing the rest
//        /// of the conference.
//        /// 
//        /// An application can specify how long the endpoint is removed from default routing  or can rely
//        /// on the default duration implemented by the MCU. The default duration guarantees that an endpoint is not left out of the default mix forever.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio or if the application did not join the conference
//        ///            as a trusted applicaiton.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task RemoveFromDefaultRoutingAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRemoveFromDefaultRouting, source.EndRemoveFromDefaultRouting, endpoint, null);
//        }
        
//        /// <summary>
//        /// Removes an endpoint from the default MCU routing.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint to remove.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize sending the command.
//        /// </param>
//        /// <remarks>
//        /// This operation can only be performed by an application that joins the conference as a trusted user.
//        /// 
//        /// Removing an endpoint from the MCU default routing means that the endpoint will no longer receive or send any media to the other endpoints.
//        /// Trusted applications connected to the conference however can further communicate with that endpoint.
//        /// 
//        /// Removing an endpoint from default routing could be useful to render specific services to the endpoint while in the conference. As an example,
//        /// a trusted application can remove the endpoint from the default mix in order to play a help message to that endpoint without disturbing the rest
//        /// of the conference.
//        /// 
//        /// An application can specify how long the endpoint is removed from default routing  or can rely
//        /// on the default duration implemented by the MCU. The default duration guarantees that an endpoint is not left out of the default mix forever.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio or if the application did not join the conference
//        ///            as a trusted applicaiton.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the  parameter contains a duration value which is less than 1 or greater than  seconds.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task RemoveFromDefaultRoutingAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint, Microsoft.Rtc.Collaboration.RemoveFromDefaultRoutingOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRemoveFromDefaultRouting, source.EndRemoveFromDefaultRouting, endpoint, options, null);
//        }
        
//        /// <summary>
//        /// Transfers an established two party Audio-Video call to the MCU.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="call">
//        /// The Audio-Video call to transfer.
//        /// </param>
//        /// <param name="mcuTransferOptions">
//        /// Optional parameters to customize the transfer request.
//        /// </param>
//        /// <remarks>
//        /// The transferred call has to be an established Call that supports transfer.
//        /// 
//        /// Unless customized using the supplied mcuTransferOptions, the call remote participant URI and display name
//        /// are used to supply the transfer request with roster information. Note that even if the participant URI and display name are supplied in
//        /// the mcuTransferOptions, the MCU may override those values with the asserted identity of the transferred endpoint.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the command is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task TransferAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoCall call, Microsoft.Rtc.Collaboration.McuTransferOptions mcuTransferOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTransfer, source.EndTransfer, call, mcuTransferOptions, null);
//        }
        
//        /// <summary>
//        /// Enables the audio coming from the supplied participant endpoint to be sent to the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint of which audio should be affected.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio to mute.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task UnmuteAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUnmute, source.EndUnmute, endpoint, null);
//        }
        
//        /// <summary>
//        /// Enables the audio coming from the supplied participant endpoint to be sent to the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="endpoint">
//        /// The endpoint of which audio should be affected.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the un-mute operation. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        ///            Also thrown if the supplied endpoint is not in the MCU or has no audio to mute.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied endpoint is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task UnmuteAsync(this Microsoft.Rtc.Collaboration.AudioVideo.AudioVideoMcuSession source, Microsoft.Rtc.Collaboration.ParticipantEndpoint endpoint, Microsoft.Rtc.Collaboration.AudioVideo.UnmuteOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUnmute, source.EndUnmute, endpoint, options, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to establish the back-to-back call between two call legs.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if BackToBack call is not in the Idle state when the method is called.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed. This failure could be a failure to establish outgoing callleg 
//        ///            or failure to accept incoming call.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub-operations of this operation failed due to errors such as connection failure or authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishAsync(this Microsoft.Rtc.Collaboration.BackToBackCall source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, null);
//        }
        
//        /// <summary>
//        /// Begins the asynchronous operation to terminate both call legs of BackToBackCall.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameter for terminating the BackToBackCall.
//        /// </param>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid or restricted headers.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.BackToBackCall source, Microsoft.Rtc.Collaboration.BackToBackCallTerminateOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, options, null);
//        }
        
//        /// <summary>
//        /// Begins the asynchronous operation to terminate both call legs of BackToBackCall.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.BackToBackCall source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Initialize the request to get a single token from given MRAS server. Once the MediaRelayToken
//        /// is received, it will be cached and automatically refreshed before expiry.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task InitializeAsync(this Microsoft.Rtc.Internal.Collaboration.CachedMediaRelayToken source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginInitialize, source.EndInitialize, null);
//        }
        
//        /// <summary>
//        /// Initialize the request to get multiple tokens from given MRAS server. Once MediaRelayTokens are received, they will
//        /// be cached and automatically refreshed before expiry.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="requestList">
//        /// List of request data to be sent with request.
//        /// </param>
//        /// <param name="route">
//        /// The MediaRelayTokenRequestRoute value to be used for the request.
//        /// </param>
//        public static System.Threading.Tasks.Task InitializeAsync(this Microsoft.Rtc.Internal.Collaboration.CachedMediaRelayToken source, System.Collections.Generic.ICollection<Microsoft.Rtc.Internal.Collaboration.MediaRelayTokenRequestData> requestList, Microsoft.Rtc.Internal.Collaboration.MediaRelayTokenRequestRoute route)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginInitialize, source.EndInitialize, requestList, route, null);
//        }
        
//        /// <summary>
//        /// Accepts an incoming call.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// The state of the call can change if the remote party decides to cancel the call.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed SIP response received with an Ack response.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is in invalid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.CallOperationFailureException">
//        /// Thrown when any of the sub-operations fail due to media provider-related issues.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub-operations of this operation fail due to SIP-related errors, such as connection failure or authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> AcceptAsync(this Microsoft.Rtc.Collaboration.Call source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginAccept, source.EndAccept, null);
//        }
        
//        /// <summary>
//        /// Accepts an incoming call with given options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to be used when accepting the call.
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with an Ack response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid headers, restricted headers or 
//        ///            invalid accepted content identifiers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is in an invalid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.CallOperationFailureException">
//        /// Thrown when any of the sub-operations fail due to media provider-related issues.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub-operations of this operation fail due to SIP-related errors, such as connection failure or authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> AcceptAsync(this Microsoft.Rtc.Collaboration.Call source, Microsoft.Rtc.Collaboration.CallAcceptOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginAccept, source.EndAccept, options, null);
//        }
        
//        /// <summary>
//        /// Establishes an outgoing call.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in valid state to perform this operation or does not have valid media provider to bind to.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.Call source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, null);
//        }
        
//        /// <summary>
//        /// Establishes an outgoing call with given options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to establish the call.
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid or restricted signaling headers. Also thrown when
//        ///            the call is used as a third party call controller with custom MIME parts or with early media support.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in valid state to perform this operation or does not have valid media provider to bind to.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.Call source, Microsoft.Rtc.Collaboration.CallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, options, null);
//        }
        
//        /// <summary>
//        /// Establishes an outgoing call.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The destination URI for the call.
//        /// </param>
//        /// <param name="options">
//        /// The optional parameters to be used when establishing the call.
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the
//        ///             parameter is null, empty or invalid sip URI or tel URI.
//        ///             parameter contains invalid or restricted signaling headers. 
//        ///            
//        ///            The call is used as a third party call controller with custom MIME parts or with early media support.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in valid state to perform this operation or does not have valid media provider to bind to.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.Call source, string destinationUri, Microsoft.Rtc.Collaboration.CallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, destinationUri, options, null);
//        }
        
//        /// <summary>
//        /// Sends an INFO message to the remote participant of this call.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contentType">
//        /// Content type of the INFO message.
//        ///            This parameter cannot be null.
//        /// </param>
//        /// <param name="contentBody">
//        /// Content body of the INFO message.
//        ///            This parameter cannot be null.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers to be included in the outgoing INFO message.
//        ///            This parameter can be null.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter or  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is in an invalid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub-operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub-operations of this operation failed due to SIP-related errors such as connection failure or authentication failure.
//        /// </exception>
//        [System.ObsoleteAttribute("This method will be removed from future versions. AudioVideoCall users can refer " +
//            "to AudioVideoCall.BeginSendMessage(). Derived class implementation can refer to " +
//            "protected method BeginSendMessage().")]
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendInfoAsync(this Microsoft.Rtc.Collaboration.Call source, System.Net.Mime.ContentType contentType, byte[] contentBody, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendInfo, source.EndSendInfo, contentType, contentBody, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Terminates the call. After the call is terminated it is no longer usable.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.Call source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Terminates the call. After the call is terminated it is no longer usable.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to be applied in terminating the call. Can be null.
//        /// </param>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when:
//        ///            The  parameter contains invalid or restricted headers.The  parameter contains invalid diagnostics information. See .
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.Call source, Microsoft.Rtc.Collaboration.CallTerminateOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, options, null);
//        }
        
//        /// <summary>
//        /// Terminates the call. After the call is terminated it is no longer usable.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The collection of signaling headers to attach to call termination request. Can be null.
//        /// </param>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid or restricted headers.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.Call source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Sends the transfer notification. This will result in sending Notification to the transferor explicitly.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The specific response code.
//        /// </param>
//        /// <param name="notificationOptions">
//        /// Optional parameters to include when sending notification. Can be null.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is already terminated, sending transfer notification operation is not allowed or
//        ///            application has not accepted the incoming transfer request by disabling sending implicit transfer notifications yet.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the response code is out of range.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is called multiple times using the same asyncResult or
//        ///            when this method is called before the application accepted the incoming transfer request by 
//        ///            disabling sending implicit transfer notifications.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid asyncResult are passed(may be an asyncResult created from some other
//        ///            operation other than BeginSetState).
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when a non-null value is expected for an argument.  The argument name for which a 
//        ///            non-null is expected is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Encompasses SIP error or failure cases encountered while trying to set refer state
//        ///            - SIP Transport error, SIP Authentication and credential related errors.
//        /// </exception>
//        public static System.Threading.Tasks.Task SendTransferNotificationAsync(this Microsoft.Rtc.Collaboration.CallTransferReceivedEventArgs source, int responseCode, Microsoft.Rtc.Collaboration.CallTransferNotificationOptions notificationOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSendTransferNotification, source.EndSendTransferNotification, responseCode, notificationOptions, null);
//        }
        
//        /// <summary>
//        /// Dynamically changes the certificate to be used.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="certificate">
//        /// The new certificate.
//        /// </param>
//        /// <remarks>
//        /// For auto-provisioned platforms this method need not be used since certificate changes are automatically applied.In order to change the certficate, the platform needs to stop listening,
//        /// change the certificate, and start listening again. While this does not affect existing connections,
//        /// there could be a temporary problem in accepting new incoming connections.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the platform has not been configured with MTLS.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the platform is not in the correct state to change the certificate.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when one or more of the arguments are null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.TlsFailureException">
//        /// Thrown when the certificate is invalid or otherwise unusable.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ConnectionFailureException">
//        /// Thrown when listening failed on the active IP EndPoint.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the start or stop operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed.
//        /// </exception>
//        public static System.Threading.Tasks.Task ChangeCertificateAsync(this Microsoft.Rtc.Collaboration.CollaborationPlatform source, System.Security.Cryptography.X509Certificates.X509Certificate certificate)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginChangeCertificate, source.EndChangeCertificate, certificate, null);
//        }
        
//        /// <summary>
//        /// Dynamically changes the certificate to be used.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="certificateIssuerName">
//        /// The issuer name for the new certificate.
//        /// </param>
//        /// <param name="certificateSerialNumber">
//        /// The serial number for the new certificate.
//        /// </param>
//        /// <remarks>
//        /// For auto-provisioned platforms this method need not be used since certificate changes are automatically applied.In order to change the certficate, the platform needs to stop listening,
//        /// change the certificate, and start listening again. While this does not affect existing connections,
//        /// there could be a temporary problem in accepting new incoming connections.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the platform has not been configured with MTLS.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the platform is not in the correct state to change the certificate.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when one of more arguments are null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when one or more of the arguments are invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.TlsFailureException">
//        /// Thrown when the certificate is invalid or unusable.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ConnectionFailureException">
//        /// Thrown when listening failed on the active IP EndPoint.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the start or stop operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed.
//        /// </exception>
//        public static System.Threading.Tasks.Task ChangeCertificateAsync(this Microsoft.Rtc.Collaboration.CollaborationPlatform source, string certificateIssuerName, byte[] certificateSerialNumber)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginChangeCertificate, source.EndChangeCertificate, certificateIssuerName, certificateSerialNumber, null);
//        }
        
//        /// <summary>
//        /// Shuts down the platform and all known endpoints.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// When it is shut down, the platform terminates all the endpoints and frees all its resources.
//        /// The platform cannot be used after this completes.This operation should never throw.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task ShutdownAsync(this Microsoft.Rtc.Collaboration.CollaborationPlatform source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginShutdown, source.EndShutdown, null);
//        }
        
//        /// <summary>
//        /// Initializes the platform object.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Once the platform is started up it can be used to create endpoints.
//        /// In case of auto-provisioned CollaborationPlatform the provisioning information for
//        /// the application is fetched during startup. It also subscribes to changes in
//        /// provisioning information such as addition or removal of application
//        /// endpoint owners, changes to configured certificate, etc.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the platform has already been started or has been terminated.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the platform is already started or terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.TlsFailureException">
//        /// Thrown when the certificate is invalid or otherwise unusable.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ConnectionFailureException">
//        /// Thrown when the platform could not listen on any of the configured IP endpoints. Check if some other process is already using the port.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ProvisioningFailureException">
//        /// Thrown when provisioning data could not be retrieved or was unusable.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task StartupAsync(this Microsoft.Rtc.Collaboration.CollaborationPlatform source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginStartup, source.EndStartup, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to accept the incoming conference invitation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown in these two cases:
//        ///            The signaling session is in an invalid stateThis method is called after the invitation has expired or one of the response methods has already been called.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when a transport error occurs while sending the response.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when this operation failed with a known reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task AcceptAsync(this Microsoft.Rtc.Collaboration.ConferenceInvitation source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAccept, source.EndAccept, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to accept the incoming conference invitation with the given .
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters for accepting the conference invitation.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when:
//        ///            The signaling session is in an invalid state.This method is called after the invitation has expired or one of the response methods has already been called.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when a transport error occurs while sending the response.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when this operation failed with a known reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task AcceptAsync(this Microsoft.Rtc.Collaboration.ConferenceInvitation source, Microsoft.Rtc.Collaboration.ConferenceInvitationAcceptOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAccept, source.EndAccept, options, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to deliver the conference invitation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The URI to which the invitation to the conference will be sent.
//        /// </param>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid URI.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the conversation is not in a valid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when this invitation was not accepted.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when this operation failed with a known reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceInvitationResponse> DeliverAsync(this Microsoft.Rtc.Collaboration.ConferenceInvitation source, string destinationUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceInvitationResponse>.Factory.FromAsync(source.BeginDeliver, source.EndDeliver, destinationUri, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to deliver the conference invitation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The URI to which the invitation to the conference will be sent.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to deliver the invitation.
//        /// </param>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid URI or when the  parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the conversation or conference is not in a valid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when this invitation was not accepted.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when this operation failed with a known reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceInvitationResponse> DeliverAsync(this Microsoft.Rtc.Collaboration.ConferenceInvitation source, string destinationUri, Microsoft.Rtc.Collaboration.ConferenceInvitationDeliverOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceInvitationResponse>.Factory.FromAsync(source.BeginDeliver, source.EndDeliver, destinationUri, options, null);
//        }
        
//        /// <summary>
//        /// Deletes a conference scheduled by the endpoint owner.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conferenceId">
//        /// The ID of the conference to delete.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for existing conferences scheduled by the endpoint owner only.
//        /// 
//        /// This operation will only delete conferences that were scheduled with settings coming from the organizer..
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the conference ID is not specified or invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when deleting a conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when deleting a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task CancelConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, string conferenceId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginCancelConference, source.EndCancelConference, conferenceId, null);
//        }
        
//        /// <summary>
//        /// Deletes a conference scheduled by the endpoint owner.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conferenceId">
//        /// The ID of the conference to delete.
//        /// </param>
//        /// <param name="schedulingTemplate">
//        /// The template used in scheduling the conference.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for existing conferences scheduled by the endpoint owner only.
//        /// 
//        /// In order to delete a conference scheduled based on an administrator template,  should be set to
//        /// . Note that most UCMA applications should not cancel such conferences as this is
//        /// an advanced scenario.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the conference ID is not specified or invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when deleting a conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when deleting a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task CancelConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, string conferenceId, Microsoft.Rtc.Collaboration.SchedulingTemplate schedulingTemplate)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginCancelConference, source.EndCancelConference, conferenceId, schedulingTemplate, null);
//        }
        
//        /// <summary>
//        /// Gets whether the conference passcode is optional.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conferenceAddress">
//        /// The conference address to check.
//        /// </param>
//        /// <remarks>
//        /// This method requires an endpoint that supports privileged operations.
//        /// </remarks>
//        /// <returns>
//        /// True if the passcode is optional, false if the passcode is required.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request or when the endpoint does not support privileged operations.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown if the supplied conference address was null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when retrieving conference passcode setting failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when retrieving conference passcode setting failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<bool> CheckPasscodeIsOptionalAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, Microsoft.Rtc.Signaling.RealTimeAddress conferenceAddress)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<bool>.Factory.FromAsync(source.BeginCheckPasscodeIsOptional, source.EndCheckPasscodeIsOptional, conferenceAddress, null);
//        }
        
//        /// <summary>
//        /// Gets the conference information of a conference scheduled by the endpoint owner.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conferenceId">
//        /// The ID of the conference to retrieve information for.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for existing conferences scheduled by the endpoint owner only.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the conference ID is not specified or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when retrieving conference information failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when retrieving conference information  failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Conference> GetConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, string conferenceId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Conference>.Factory.FromAsync(source.BeginGetConference, source.EndGetConference, conferenceId, null);
//        }
        
//        /// <summary>
//        /// Gets a list of basic conference information for conferences scheduled by the endpoint owner.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This operation is only allowed by the server for existing conferences scheduled by the endpoint owner.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when retrieving conferences summary information failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when retrieving conferences summary information failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<System.Collections.ObjectModel.Collection<Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceSummary>> GetConferenceSummariesAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<System.Collections.ObjectModel.Collection<Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceSummary>>.Factory.FromAsync(source.BeginGetConferenceSummaries, source.EndGetConferenceSummaries, null);
//        }
        
//        /// <summary>
//        /// Gets a list of basic conference information for conferences scheduled using the supplied
//        /// scheduling template.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="schedulingTemplate">
//        /// The template used in scheduling the conference.
//        /// </param>
//        /// <remarks>
//        /// This operation is only allowed by the server for existing conferences scheduled by the endpoint owner.Microsoft Lync Server 2010 allows one administrator-supplied conference per user.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when retrieving conferences summary information failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when retrieving conferences summary information failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<System.Collections.ObjectModel.Collection<Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceSummary>> GetConferenceSummariesAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, Microsoft.Rtc.Collaboration.SchedulingTemplate schedulingTemplate)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<System.Collections.ObjectModel.Collection<Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceSummary>>.Factory.FromAsync(source.BeginGetConferenceSummaries, source.EndGetConferenceSummaries, schedulingTemplate, null);
//        }
        
//        /// <summary>
//        /// Translates a phone conference ID to a conference URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="phoneConferenceId">
//        /// The key used to lookup a conference URI.
//        /// </param>
//        /// <remarks>
//        /// This method requires an endpoint that supports privileged operations.
//        /// </remarks>
//        /// <returns>
//        /// The conference URI.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request or when the endpoint does not support privileged operations.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if the supplied phone conference ID string was null or empty.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when retrieving the conference URI failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when retrieving the conference URI failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<string> GetConferenceUriByPhoneConferenceIdAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, string phoneConferenceId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<string>.Factory.FromAsync(source.BeginGetConferenceUriByPhoneConferenceId, source.EndGetConferenceUriByPhoneConferenceId, phoneConferenceId, null);
//        }
        
//        /// <summary>
//        /// Gets the conferencing options that are available to the endpoint owner.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Most of the conferencing options available to the endpoint owner are retrieved by calling this method.
//        /// The rest of the options are retrieved in the meeting policy section of the endpoint provisioning data.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when retrieving conferencing capabilities failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when retrieving conferencing capabilities failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferencingCapabilities> GetConferencingCapabilitiesAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferencingCapabilities>.Factory.FromAsync(source.BeginGetConferencingCapabilities, source.EndGetConferencingCapabilities, null);
//        }
        
//        /// <summary>
//        /// Initiates the scheduling of a conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="information">
//        /// Information used to schedule the conference.
//        /// </param>
//        /// <returns>
//        /// Information about the scheduled conference.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied information instance is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when scheduling a conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when scheduling a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Conference> ScheduleConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceScheduleInformation information)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Conference>.Factory.FromAsync(source.BeginScheduleConference, source.EndScheduleConference, information, null);
//        }
        
//        /// <summary>
//        /// Updates an existing conference scheduled by the endpoint owner.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="information">
//        /// Information used to update the existing conference. The conference ID property should be set to the ID of the conference to be modified.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for existing conferences scheduled by the endpoint owner only.
//        /// </remarks>
//        /// <returns>
//        /// Information about the updated conference.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the information instance passed was null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the information instance passed does not contain a conference ID.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when updating a conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when updating a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Conference> UpdateConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceScheduleInformation information)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Conference>.Factory.FromAsync(source.BeginUpdateConference, source.EndUpdateConference, information, null);
//        }
        
//        /// <summary>
//        /// Gets whether the supplied passcode is valid for the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conferenceAddress">
//        /// The conference address.
//        /// </param>
//        /// <param name="passcode">
//        /// The passcode to verify.
//        /// </param>
//        /// <remarks>
//        /// This method requires an endpoint that supports privileged operations.
//        /// </remarks>
//        /// <returns>
//        /// True if the passcode is valid, false if the passcode is invalid.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method failed to issue the request or when the endpoint does not support privileged operations.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied conference address or passcode were null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied passcode was empty.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when verifying conference passcode failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when verifying conference passcode setting failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<bool> VerifyPasscodeAsync(this Microsoft.Rtc.Collaboration.ConferenceManagement.ConferenceServices source, Microsoft.Rtc.Signaling.RealTimeAddress conferenceAddress, string passcode)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<bool>.Factory.FromAsync(source.BeginVerifyPasscode, source.EndVerifyPasscode, conferenceAddress, passcode, null);
//        }
        
//        /// <summary>
//        /// Ejects all endpoints of a participant from the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participant">
//        /// The participant to eject.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the participant argument was null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when ejecting a participant timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when ejecting a participant failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when ejecting a participant failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EjectAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConversationParticipant participant)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEject, source.EndEject, participant, null);
//        }
        
//        /// <summary>
//        /// Ejects all endpoints of a participant from the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participant">
//        /// The participant to eject.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize ejecting a participant.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the participant argument was null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when ejecting a participant timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when ejecting a participant failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when ejecting a participant failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EjectAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConversationParticipant participant, Microsoft.Rtc.Collaboration.EjectOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEject, source.EndEject, participant, options, null);
//        }
        
//        /// <summary>
//        /// Gets the extended properties of the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// The conference extended properties include information about accessing the conference using a phone. See .
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown for other failures including when the lobby wait period is set to zero in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when joining a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceSessionExtendedProperties> GetExtendedPropertiesAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceSessionExtendedProperties>.Factory.FromAsync(source.BeginGetExtendedProperties, source.EndGetExtendedProperties, null);
//        }
        
//        /// <summary>
//        /// This method will be removed from future versions. Instead, use  to join a conference.
//        /// Creates and joins an ad-hoc conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Joining a conference is required to receive roster events on the
//        /// and  derivatives.
//        /// 
//        /// The platform schedules a conference valid for 8 hours with an MCU for all the available MCU factories.
//        /// However, the audio-video MCU will only be scheduled if inband provisioning data for the endpoint is available
//        /// and indicates that the endpoint owner is provisioned for audio.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when joining a conference timed out waiting for a reply or if the participant was placed
//        ///            in the lobby for a period larger than that set in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when joining a conference failed with a Centralized Conference Control Protocol (C3P) body in the response or when the participant is placed in the lobby and
//        ///            then was denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureRequestException">
//        /// Thrown when the participant was disconnected from the lobby due to a reason other than being denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown for other failures including when the lobby wait period is set to zero in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when joining a conference failed without a C3P body in the response.
//        /// </exception>
//        [System.ObsoleteAttribute("This method will be removed from future versions. Use BeginJoin(ConferenceJoinOpt" +
//            "ions options,AsyncCallback userCallback, object state) or BeginJoin(string confe" +
//            "renceUri,ConferenceJoinOptions options,AsyncCallback userCallback, object state)" +
//            "")]
//        public static System.Threading.Tasks.Task JoinAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginJoin, source.EndJoin, null);
//        }
        
//        /// <summary>
//        /// This method will be removed from future versions. Instead, use  to join a conference.
//        /// Joins a conference based on the provided join information.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="information">
//        /// Information to customize the join operation.
//        /// </param>
//        /// <remarks>
//        /// Joining a conference is required to receive roster events on the
//        /// and  implementations.
//        /// 
//        /// An endpoint supporting privileged operations is required to join as a trusted application.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the information argument was null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when joining a conference timed out waiting for a reply or if the participant was placed
//        ///            in the lobby for a period larger than that set in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when joining a conference failed with a Centralized Conference Control Protocol (C3P) body in the response or when the participant is placed in the lobby and
//        ///            then was denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureRequestException">
//        /// Thrown when the participant was disconnected from the lobby due to a reason other than being denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown for other failures including when the lobby wait period is set to zero in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when joining a conference failed without a C3P body in the response.
//        /// </exception>
//        [System.ObsoleteAttribute("This method will be removed from future versions. Use BeginJoin(ConferenceJoinOpt" +
//            "ions options,AsyncCallback userCallback, object state) or BeginJoin(string confe" +
//            "renceUri,ConferenceJoinOptions options,AsyncCallback userCallback, object state)" +
//            "")]
//        public static System.Threading.Tasks.Task JoinAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConferenceJoinInformation information)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginJoin, source.EndJoin, information, null);
//        }
        
//        /// <summary>
//        /// Joins a conference based on the provided join options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options to customize joining a conference. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// Joining a conference is required to receive roster events on the
//        /// and  implementations.
//        /// 
//        /// An endpoint supporting privileged operations is required to join as a trusted application.
//        /// 
//        /// Applications can customize joining a conference by passing a  instance.
//        /// 
//        /// If the parent  instance has already received and accepted a conference invitation, or received an MCU dial-out, then calling this method
//        /// will join the application to the specific conference it was invited.
//        /// 
//        /// If, however, the application was not invited to a conference through a conference invitation or an MCU dial-out, then the platform organizes an ad-hoc conference,
//        /// and the application is joined to that conference.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when joining a conference timed out waiting for a reply or if the participant was placed
//        ///            in the lobby for a period larger than that set in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when joining a conference failed with a Centralized Conference Control Protocol (C3P) body in the response or when the participant is placed in the lobby and
//        ///            then was denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureRequestException">
//        /// Thrown when the participant was disconnected from the lobby due to a reason other than being denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown for other failures including when the lobby wait period is set to zero in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when joining a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task JoinAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConferenceJoinOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginJoin, source.EndJoin, options, null);
//        }
        
//        /// <summary>
//        /// Creates and joins an ad hoc conference conference with the widest possible audience.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="meetNowOptions">
//        /// Options to customize joining a conference. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// Applications can customize joining a conference by passing a  instance.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when joining a conference timed out waiting for a reply or if the participant was placed
//        ///            in the lobby for a period larger than that set in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when joining a conference failed with a Centralized Conference Control Protocol (C3P) body in the response or when the participant is placed in the lobby and
//        ///            then was denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureRequestException">
//        /// Thrown when the participant was disconnected from the lobby due to a reason other than being denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown for other failures including when the lobby wait period is set to zero in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when joining a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task JoinAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.MeetNowOptions meetNowOptions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginJoin, source.EndJoin, meetNowOptions, null);
//        }
        
//        /// <summary>
//        /// Joins a conference based on the provided conference URI and join options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conferenceUri">
//        /// The URI of the conference to join.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize joining a conference. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// Joining a conference is required to receive roster events on the
//        /// and  implementations.
//        /// 
//        /// An endpoint supporting privileged operations is required to join as a trusted application.
//        /// 
//        /// Applications can customize joining a conference by passing a  instance.
//        /// 
//        /// An application may land in the lobby depending on how it joined the conference and the current conference settings. An application joining
//        /// a conference as trusted will never land in the conference lobby.
//        /// 
//        /// When an application lands in the lobby, the  will be transitioned to  and the
//        /// will be also transitioned to . The  will
//        /// not be invoked until the application has either been admitted into the conference by a leader, removed from the lobby by a leader or left the lobby.
//        /// 
//        /// If the application was admitted into the conference, the  method will not throw any exceptions. The
//        /// will be transitioned to  and the  will be transitioned to .
//        /// On the other hand, if the application was removed from the lobby by a conference leader, the  method will throw a
//        /// with  set to set to  or .
//        /// 
//        /// When an application leaves the lobby by calling , then the  method
//        /// will throw an . An  will be thrown if the application lobby wait period expired.
//        /// 
//        /// Lobby participants receive limited information about the conference, therefore not all the  properties are populated while in the lobby.
//        /// Also, lobby participants do not receive any information about other participants in the conference or waiting in the lobby and they are not able to
//        /// perform any operations on the conference like modifying the conference access level.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state or if the application attempted to join a difference
//        ///            conference after it received a conference invitation or an Mcu dial-out.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied  is null or empty.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when joining a conference timed out waiting for a reply or if the participant was placed
//        ///            in the lobby for a period larger than that set in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when joining a conference failed with a Centralized Conference Control Protocol (C3P) body in the response or when the participant is placed in the lobby and
//        ///            then was denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureRequestException">
//        /// Thrown when the participant was disconnected from the lobby due to a reason other than being denied access or removed from the conference by a leader.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown for other failures including when the lobby wait period is set to zero in .
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when joining a conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task JoinAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, string conferenceUri, Microsoft.Rtc.Collaboration.ConferenceJoinOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginJoin, source.EndJoin, conferenceUri, options, null);
//        }
        
//        /// <summary>
//        /// Locks the joined conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// Any attendees joining a conference after it gets locked are placed into the conference lobby.
//        /// Participants placed in the conference lobby are not visible to applications built on UCMA 2.0. However, if admitted into the conference by
//        /// a conference leader, they become visible to the application.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when locking the conference timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when locking the conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when locking the conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task LockConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginLockConference, source.EndLockConference, null);
//        }
        
//        /// <summary>
//        /// Locks the joined conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options to customize locking the conference.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// Any attendees joining a conference after it gets locked are placed into the conference lobby.
//        /// Participants placed in the conference lobby are not visible to applications built on UCMA 2.0. However, if admitted into the conference by
//        /// a conference leader, they become visible to the application.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when locking the conference timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when locking the conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when locking the conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task LockConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.LockConferenceOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginLockConference, source.EndLockConference, options, null);
//        }
        
//        /// <summary>
//        /// Modifies conference configuration.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="accessLevel">
//        /// The new access level.
//        /// </param>
//        /// <param name="lobbyBypass">
//        /// New lobby bypass setting.
//        /// </param>
//        /// <param name="automaticLeaderAssignment">
//        /// The new automatic leader assignment setting.
//        /// </param>
//        /// <remarks>
//        /// A conference leader can allow specific types of users to bypass the lobby and get admitted directly into the conference although under normal conditions
//        /// those users are placed in the lobby. As an example, a conference leader may allow participants joining over the phone to bypass the lobby.
//        /// Note however, if the conference current access level is , all new users joining the conference - regardless of any bypass setting -
//        /// are placed in the conference lobby.
//        /// 
//        /// Conference access level determines which users are admitted into the conference or placed in the lobby. When a conference is first activated
//        /// (by the first user attempting to the join the conference), the initial access level applied is whatever level that was set by the organizer (i.e. at scheduling time).
//        /// Any changes to the access level performed by this method are lost after the conference is deactivated.
//        /// 
//        /// Applications should call the  method before calling this method
//        /// to retrieve the allowed access levels the conference could be changed to.
//        /// 
//        /// Note: An application may not wish to change all configuration settings at once. In this case it can use the properties on conference session to
//        /// get the current cached value of the setting to prevent the setting from being changed. In some cases where two leaders are making changes in a
//        /// short time interval, it may be possible that the cached version of the setting does not reflect the most current value at the server,
//        /// and could overwrite the value as set by another leader.  The setting would have to then be reapplied.
//        /// 
//        /// This operation can only be performed by a conference leader.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid in the current conference session state or the joined conference is one that
//        ///            has been migrated from earlier server version and is running in compatibility mode.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when an argument passed has an invalid value.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task ModifyConferenceConfigurationAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConferenceAccessLevel accessLevel, Microsoft.Rtc.Collaboration.LobbyBypass lobbyBypass, Microsoft.Rtc.Collaboration.AutomaticLeaderAssignment automaticLeaderAssignment)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginModifyConferenceConfiguration, source.EndModifyConferenceConfiguration, accessLevel, lobbyBypass, automaticLeaderAssignment, null);
//        }
        
//        /// <summary>
//        /// Modifies conference configuration.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="accessLevel">
//        /// The new access level.
//        /// </param>
//        /// <param name="lobbyBypass">
//        /// New lobby bypass setting.
//        /// </param>
//        /// <param name="automaticLeaderAssignment">
//        /// The new automatic leader assignment setting.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the operation. Could be null.
//        /// </param>
//        /// <remarks>
//        /// A conference leader can allow specific types of users to bypass the lobby and get admitted directly into the conference although under normal conditions
//        /// those users are placed in the lobby. As an example, a conference leader may allow participants joining over the phone to bypass the lobby.
//        /// Note however, if the conference current access level is , all new users joining the conference - regardless of any bypass setting -
//        /// are placed in the conference lobby.
//        /// 
//        /// Conference access level determines which users are admitted into the conference or placed in the lobby. When a conference is first activated
//        /// (by the first user attempting to the join the conference), the initial access level applied is whatever level that was set by the organizer (i.e. at scheduling time).
//        /// Any changes to the access level performed by this method are lost after the conference is deactivated.
//        /// 
//        /// Applications should call the  methodbefore calling this method
//        /// to retrieve the allowed access levels the conference could be changed to.
//        /// 
//        /// Note: An application may not wish to change all configuration settings at once. In this case it can use the properties on conference session to
//        /// get the current cached value of the setting to prevent the setting from being changed. In some cases where two leaders are making changes in a
//        /// short time interval, it may be possible that the cached version of the setting does not reflect the most current value at the server,
//        /// and could overwrite the value as set by another leader.  The setting would have to then be reapplied.
//        /// 
//        /// This operation can only be performed by a conference leader.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid in the current conference session state or the joined conference is one that
//        ///            has been migrated from earlier server version and is running in compatibility mode.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when an argument passed has an invalid value.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task ModifyConferenceConfigurationAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConferenceAccessLevel accessLevel, Microsoft.Rtc.Collaboration.LobbyBypass lobbyBypass, Microsoft.Rtc.Collaboration.AutomaticLeaderAssignment automaticLeaderAssignment, Microsoft.Rtc.Collaboration.ModifyConferenceConfigurationOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginModifyConferenceConfiguration(accessLevel, lobbyBypass, automaticLeaderAssignment, options, null, null), source.EndModifyConferenceConfiguration);
//        }
        
//        /// <summary>
//        /// Modifies the role of a participant in the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participant">
//        /// The participant for which the role should be changed.
//        /// </param>
//        /// <param name="role">
//        /// The desired role for the participant.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the participant argument was null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when modifying the role timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when modifying the role failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when modifying the role failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task ModifyRoleAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConversationParticipant participant, Microsoft.Rtc.Collaboration.ConferencingRole role)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginModifyRole, source.EndModifyRole, participant, role, null);
//        }
        
//        /// <summary>
//        /// Modifies the role of a participant in the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participant">
//        /// The participant for which the role should be changed.
//        /// </param>
//        /// <param name="role">
//        /// The desired role for the participant.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the operation. Could be null.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the participant argument was null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when modifying the role timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when modifying the role failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when modifying the role failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task ModifyRoleAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.ConversationParticipant participant, Microsoft.Rtc.Collaboration.ConferencingRole role, Microsoft.Rtc.Collaboration.ModifyRoleOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginModifyRole, source.EndModifyRole, participant, role, options, null);
//        }
        
//        /// <summary>
//        /// Terminates the conference and forces all participants to leave if performed by a conference leader.
//        /// Otherwise it causes the participant to leave the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Unless ejecting all participants is required, the recommended way of
//        /// leaving a conference is using the  method.
//        /// </remarks>
//        public static System.Threading.Tasks.Task TerminateConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminateConference, source.EndTerminateConference, null);
//        }
        
//        /// <summary>
//        /// Unlocks a conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options to customize unlocking a conference.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when unlocking the conference timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when unlocking the conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when unlocking the conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task UnlockConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source, Microsoft.Rtc.Collaboration.UnlockConferenceOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUnlockConference, source.EndUnlockConference, options, null);
//        }
        
//        /// <summary>
//        /// Unlocks a conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when unlocking the conference timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when unlocking the conference failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when unlocking the conference failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task UnlockConferenceAsync(this Microsoft.Rtc.Collaboration.ConferenceSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUnlockConference, source.EndUnlockConference, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to add a contact.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contactUri">
//        /// URI of the contact being added.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an invalid sip URI.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndAddContact was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task AddContactAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, string contactUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddContact, source.EndAddContact, contactUri, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to add a contact.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contactUri">
//        /// URI of the contact being added.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters when creating a contact.
//        /// </param>
//        /// <remarks>
//        /// If the endpoint is operating in privacy mode then an Access Control Entry will automatically be added to the endpoint owner's
//        /// Access Control lists or containers. The notifications if this operation is successful can be obtained by wiring
//        /// .
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an invalid sip URI.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when are null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when any of options.GroupIds is negative.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndAddContact was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task AddContactAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, string contactUri, Microsoft.Rtc.Collaboration.ContactsGroups.ContactAddOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddContact, source.EndAddContact, contactUri, options, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to add a contact.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contactUri">
//        /// URI of the contact being added.
//        /// </param>
//        /// <param name="contactName">
//        /// Name of the contact being added.
//        /// </param>
//        /// <param name="isSubscribed">
//        /// True, if this contact also needs to be subscribed.
//        /// </param>
//        /// <param name="contactData">
//        /// ContactData.
//        /// </param>
//        /// <param name="contactExtension">
//        /// ContactExtension data needs to be published with this contact.
//        /// </param>
//        /// <param name="groupIds">
//        /// List of GroupIds where this contact would be added.
//        /// </param>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when any of the  are less than zero.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an invalid sip URI.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  or are null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndAddContact was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        [System.ObsoleteAttribute("This method will be removed from future Versions. Please use BeginAddContact(cont" +
//            "actUri, options, userCallback, state) instead.")]
//        public static System.Threading.Tasks.Task AddContactAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, string contactUri, string contactName, bool isSubscribed, string contactData, string contactExtension, int[] groupIds)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddContact(contactUri, contactName, isSubscribed, contactData, contactExtension, groupIds, null, null), source.EndAddContact);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to add a group.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="groupName">
//        /// Name of the group to be added.
//        /// </param>
//        /// <param name="groupData">
//        /// Data to be associated with the group.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is empty.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndAddGroup was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task AddGroupAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, string groupName, string groupData)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddGroup, source.EndAddGroup, groupName, groupData, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to remove a specified contact.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contactUri">
//        /// The contact to be deleted.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is empty.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndDeleteContact was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task DeleteContactAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, string contactUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDeleteContact, source.EndDeleteContact, contactUri, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to remove a specified group.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="groupId">
//        /// ID of the group to be deleted.
//        /// </param>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when  is less than zero.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndDeleteGroup was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task DeleteGroupAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, int groupId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDeleteGroup, source.EndDeleteGroup, groupId, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to get a cached contact.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contactUri">
//        /// Contact to get information about.
//        /// </param>
//        /// <returns>
//        /// Information about the contact.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is invalid.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndCachedContact was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ContactsGroups.Contact> GetCachedContactAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, string contactUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ContactsGroups.Contact>.Factory.FromAsync(source.BeginGetCachedContact, source.EndGetCachedContact, contactUri, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to get a cached group.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="groupId">
//        /// Group to get information about.
//        /// </param>
//        /// <returns>
//        /// Information about the group.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is not positive.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndGetCachedGroup was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ContactsGroups.Group> GetCachedGroupAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, int groupId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ContactsGroups.Group>.Factory.FromAsync(source.BeginGetCachedGroup, source.EndGetCachedGroup, groupId, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to refresh the subscription.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription was not previously established.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task RefreshAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRefresh, source.EndRefresh, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to update the information for the specified contact.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contact">
//        /// Contact to be updated.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndUpdateContact was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdateContactAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, Microsoft.Rtc.Collaboration.ContactsGroups.Contact contact)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdateContact, source.EndUpdateContact, contact, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to update the information for a specified group.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="group">
//        /// Group to be updated.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription state is not idle or subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndUpdateGroup was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdateGroupAsync(this Microsoft.Rtc.Collaboration.ContactsGroups.ContactGroupServices source, Microsoft.Rtc.Collaboration.ContactsGroups.Group group)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdateGroup, source.EndUpdateGroup, group, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to escalate the conversation to a conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// The conversation must already be joined to a conference before calling this method.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the conversation is not in a proper state for conference escalation
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EscalateToConferenceAsync(this Microsoft.Rtc.Collaboration.Conversation source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEscalateToConference, source.EndEscalateToConference, null);
//        }
        
//        /// <summary>
//        /// This method will be removed from future versions. Instead, use ConferenceInvitation.BeginDeliver().
//        /// Begins an asynchronous operation to invite remote participants to the conversations conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUris">
//        /// A enumeration of URIs to which invitations to the conference will be sent.
//        /// </param>
//        /// <param name="toastMessage">
//        /// A short message that can be displayed to the recipient upon receipt. This parameter can be null.
//        /// </param>
//        /// <remarks>
//        /// Sends a conference invitation to each of the .
//        /// 
//        /// The conversation must already be joined to a conference before calling this method.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if any of the method parameters fail validation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if the conversation does not have a valid conference session.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the delivery of the invitation failed for every remote participant to which it was addressed.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        [System.ObsoleteAttribute("This method will be removed from future versions. See ConferenceInvitation.BeginD" +
//            "eliver for more information")]
//        public static System.Threading.Tasks.Task InviteRemoteParticipantsAsync(this Microsoft.Rtc.Collaboration.Conversation source, System.Collections.Generic.IEnumerable<string> destinationUris, Microsoft.Rtc.Collaboration.ToastMessage toastMessage)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginInviteRemoteParticipants, source.EndInviteRemoteParticipants, destinationUris, toastMessage, null);
//        }
        
//        /// <summary>
//        /// This method will be removed from future versions. For more information, see ConferenceInvitation.BeginDeliver().
//        /// Begins an asynchronous operation to invite remote participants to the conversations conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUris">
//        /// A enumeration of URIs to which invitations to the conference will be sent.
//        /// </param>
//        /// <param name="mediaTypes">
//        /// An enumeration of media types to be added to the invitation.
//        /// </param>
//        /// <param name="toastMessage">
//        /// A short message which can be displayed to the recipient upon receipt. This parameter can be null.
//        /// </param>
//        /// <remarks>
//        /// Sends a conference invitation to each of the .
//        /// 
//        /// The conversation must already be joined to a conference before calling this method.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if any of the method parameters fail validation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if the conversation does not have a valid conference session.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the delivery of the invitation failed for every remote participant to which it was addressed.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        [System.ObsoleteAttribute("This method will be removed from future versions. See ConferenceInvitation.BeginD" +
//            "eliver for more information")]
//        public static System.Threading.Tasks.Task InviteRemoteParticipantsAsync(this Microsoft.Rtc.Collaboration.Conversation source, System.Collections.Generic.IEnumerable<string> destinationUris, System.Collections.Generic.IEnumerable<string> mediaTypes, Microsoft.Rtc.Collaboration.ToastMessage toastMessage)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginInviteRemoteParticipants, source.EndInviteRemoteParticipants, destinationUris, mediaTypes, toastMessage, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to terminate the conversation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Terminates the conversation by first terminating all the calls, the conference session and conference invitations
//        /// associated with this conversation.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.Conversation source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to terminate the conversation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to be applied when terminating the conversation. Can be null.
//        /// </param>
//        /// <remarks>
//        /// Terminates the conversation by first terminating all the calls, the conference session and conference invitations
//        /// associated with this conversation.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  parameter contains invalid diagnostics information .
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  has invalid diagnostics information..
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.Conversation source, Microsoft.Rtc.Collaboration.ConversationTerminateOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, options, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to update the properties of the conversation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="conversationProperties">
//        /// The new conversation properties to be updated.
//        /// </param>
//        /// <remarks>
//        /// Sends a conversation property update message.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  value is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  has no property to update.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the  has an invalid property to update.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdatePropertiesAsync(this Microsoft.Rtc.Collaboration.Conversation source, Microsoft.Rtc.Collaboration.ConversationProperties conversationProperties)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdateProperties, source.EndUpdateProperties, conversationProperties, null);
//        }
        
//        /// <summary>
//        /// Establishes the channel.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="applicationId">
//        /// The unique application guid.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishAsync(this Microsoft.Rtc.Collaboration.ConversationContextChannel source, System.Guid applicationId, Microsoft.Rtc.Collaboration.ConversationContextChannelEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, applicationId, options, null);
//        }
        
//        /// <summary>
//        /// Sends message to remote endpoint with the given content.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contentType">
//        /// 
//        /// </param>
//        /// <param name="contentBody">
//        /// 
//        /// </param>
//        public static System.Threading.Tasks.Task SendDataAsync(this Microsoft.Rtc.Collaboration.ConversationContextChannel source, System.Net.Mime.ContentType contentType, byte[] contentBody)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSendData, source.EndSendData, contentType, contentBody, null);
//        }
        
//        /// <summary>
//        /// Terminates the channel.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.ConversationContextChannel source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Set the media permissions.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="mediaPermissions">
//        /// The media permissions to set.
//        /// </param>
//        /// <remarks>
//        /// This operation is allowed by the server for conference leaders only.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied mediaPermissions is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied mediaPermissions is empty or contains a null member.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task SetMediaPermissionsAsync(this Microsoft.Rtc.Internal.Collaboration.DataCollaboration.DataCollaborationMcuSession source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaPermission> mediaPermissions)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSetMediaPermissions, source.EndSetMediaPermissions, mediaPermissions, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to starts connectivity checks between local and remote endpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if media endpoint has not been initialized.
//        /// </exception>
//        /// <exception cref="T:System.ObjectDisposedException">
//        /// Thrown if IMediaEndpoint instance has been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown if connectivty checks failed.
//        /// </exception>
//        public static System.Threading.Tasks.Task ConnectivityChecksAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginConnectivityChecks, source.EndConnectivityChecks, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to retrieve the local endpoint's transport information.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// The local endpoint's transport information.
//        /// </returns>
//        /// <exception cref="T:System.ObjectDisposedException">
//        /// Thrown if IMediaEndpoint instance has been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown when an error occurs.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Internal.Collaboration.Media.MediaTransportInfo> GetLocalMediaTransportInfoAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Internal.Collaboration.Media.MediaTransportInfo>.Factory.FromAsync(source.BeginGetLocalMediaTransportInfo, source.EndGetLocalMediaTransportInfo, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to get a MediaCryptoKeySet from the MediaEndpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// The set of cryptography keys to use in SDP negotiations.
//        /// </returns>
//        /// <exception cref="T:System.ObjectDisposedException">
//        /// Thrown if IMediaEndpoint instance has been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown if unable to crated media crypto key set.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Internal.Collaboration.Media.MediaCryptoKeySet> GetMediaCryptoKeySetAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Internal.Collaboration.Media.MediaCryptoKeySet>.Factory.FromAsync(source.BeginGetMediaCryptoKeySet, source.EndGetMediaCryptoKeySet, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to initialize the MediaEndpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="tokens">
//        /// A list of tokens for connecitvity servers.
//        /// </param>
//        /// <param name="controlling">
//        /// Indicates the ICE role.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if media endpoint has already been initialized.
//        /// </exception>
//        /// <exception cref="T:System.ObjectDisposedException">
//        /// Thrown if IMediaEndpoint instance has been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown if initialization fails.
//        /// </exception>
//        public static System.Threading.Tasks.Task InitializationAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source, System.Collections.Generic.ICollection<Microsoft.Rtc.Internal.Collaboration.MediaRelayToken> tokens, bool controlling)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginInitialization, source.EndInitialization, tokens, controlling, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to update the endpoint with the remote endpoint's transport information.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="remoteMediaTransportInfo">
//        /// The remote endpoint's transport information.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown if remoteMedaiTransportInfo is null.
//        /// </exception>
//        /// <exception cref="T:System.ObjectDisposedException">
//        /// Thrown if IMediaEndpoint instance has been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown if setting the remote media transport info fails.
//        /// </exception>
//        public static System.Threading.Tasks.Task SetRemoteMediaTransportInfoAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source, Microsoft.Rtc.Internal.Collaboration.Media.MediaTransportInfo remoteMediaTransportInfo)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSetRemoteMediaTransportInfo, source.EndSetRemoteMediaTransportInfo, remoteMediaTransportInfo, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to set the cryptography keys used to encrypt the media channel.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="localKey">
//        /// The key that will be used to encrypt outgoing data.
//        /// </param>
//        /// <param name="remoteKey">
//        /// The key that will be used to decrypt incoming data.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// If localKey or remoteKey is null.
//        /// </exception>
//        /// <exception cref="T:System.ObjectDisposedException">
//        /// Thrown if IMediaEndpoint instance has been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaOperationFailureException">
//        /// Thrown if unable to set the srtp crypto keys.
//        /// </exception>
//        public static System.Threading.Tasks.Task SetSrtpCryptoKeysAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source, Microsoft.Rtc.Internal.Collaboration.Media.SdpSrtpCryptoKey localKey, Microsoft.Rtc.Internal.Collaboration.Media.SdpSrtpCryptoKey remoteKey)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSetSrtpCryptoKeys, source.EndSetSrtpCryptoKeys, localKey, remoteKey, null);
//        }
        
//        /// <summary>
//        /// Initiates an operation to terminate all media and dispose of all resources.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Internal.Collaboration.ApplicationSharing.Media.IMediaEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Accepts an incoming call park session with specified options.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="orbitNumber">
//        /// Orbit number to use. Cannot be null.
//        /// </param>
//        /// <param name="parkedCallDialog">
//        /// Dialog information of the parked call. Cannot be null.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Optional headers to be included when accepting 
//        ///            incoming call park session.
//        /// </param>
//        /// <returns>
//        /// Returns the parsed SIP response received with an Ack response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid 
//        ///            headers, restricted headers or invalid accepted content identifiers.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  or  contains a null or empty value.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call park session is in invalid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related 
//        ///            errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task AcceptAsync(this Microsoft.Rtc.Internal.Collaboration.IncomingCallParkSession source, string orbitNumber, string parkedCallDialog, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAccept, source.EndAccept, orbitNumber, parkedCallDialog, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Sends a notification related to park operation to the park requester.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="version">
//        /// Call park version to be used in the notification.
//        /// </param>
//        /// <param name="requestId">
//        /// Request identifier to be used in the notification.
//        /// </param>
//        /// <param name="notificationReason">
//        /// Park notification reason to be used.
//        /// </param>
//        /// <param name="notificationTarget">
//        /// Park notification target to be used. This parameter can be null or empty
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers to be included in the outgoing INFO message.
//        ///            This parameter can be null.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  contain invalid or restricted headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this session is in an invalid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related 
//        ///            errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendParkNotificationAsync(this Microsoft.Rtc.Internal.Collaboration.IncomingCallParkSession source, string version, string requestId, Microsoft.Rtc.Internal.Collaboration.CallParkNotificationReason notificationReason, string notificationTarget, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendParkNotification(version, requestId, notificationReason, notificationTarget, signalingHeaders, null, null), source.EndSendParkNotification);
//        }
        
//        /// <summary>
//        /// Accepts the initial incoming session, or any refresh request received.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options to modify accept behavior.
//        /// </param>
//        public static System.Threading.Tasks.Task AcceptAsync(this Microsoft.Rtc.Internal.Signaling.IncomingSubscriptionSession source, Microsoft.Rtc.Internal.Signaling.SubscriptionSessionAcceptOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAccept, source.EndAccept, options, null);
//        }
        
//        /// <summary>
//        /// Declines the incoming session, or any refresh that is received.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The final response code to send.
//        /// </param>
//        /// <param name="options">
//        /// 
//        /// </param>
//        public static System.Threading.Tasks.Task DeclineAsync(this Microsoft.Rtc.Internal.Signaling.IncomingSubscriptionSession source, int responseCode, Microsoft.Rtc.Internal.Signaling.SubscriptionSessionDeclineOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDecline, source.EndDecline, responseCode, options, null);
//        }
        
//        /// <summary>
//        /// Sends a reliable or best effort notification to the subscriber.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options for sending the notification or null for default behavior.
//        /// </param>
//        /// <returns>
//        /// Response information if available.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// The subscription has not become established or it has terminated.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Internal.Signaling.SubscriptionNotificationResponse> SendNotificationAsync(this Microsoft.Rtc.Internal.Signaling.IncomingSubscriptionSession source, Microsoft.Rtc.Internal.Signaling.SubscriptionNotificationOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Internal.Signaling.SubscriptionNotificationResponse>.Factory.FromAsync(source.BeginSendNotification, source.EndSendNotification, options, null);
//        }
        
//        /// <summary>
//        /// Terminates the subscription session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options for terminating the subscription session.
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Internal.Signaling.IncomingSubscriptionSession source, Microsoft.Rtc.Internal.Signaling.SubscriptionSessionTerminateOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, options, null);
//        }
        
//        /// <summary>
//        /// Begins the operation of establishing the instant messaging call with the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// Destination URI of the remote participant
//        /// </param>
//        /// <param name="toastMessage">
//        /// A short message that can be displayed to the recipient upon receipt. Can be null.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to establish the call.
//        /// </param>
//        /// <remarks>
//        /// specifies the message that is displayed on the client when the callee is notified of an incoming call.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is null, empty or invalid SIP URI or tel URI, or when the
//        ///             parameter contains invalid or restricted signaling headers, or when 
//        ///            the call is used as a third-party call controller with custom MIME parts or with early media support.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in a valid state to perform this operation or does not have valid media provider to bind to.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.InstantMessagingCall source, string destinationUri, Microsoft.Rtc.Collaboration.ToastMessage toastMessage, Microsoft.Rtc.Collaboration.CallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, destinationUri, toastMessage, options, null);
//        }
        
//        /// <summary>
//        /// Begins the operation of establishing the instant messaging call on existing Conversation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="toastMessage">
//        /// A short message which can be displayed to the recipient upon receipt. Can be null.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to establish the call.
//        /// </param>
//        /// <remarks>
//        /// specifies the message that is displayed on the client when the callee is notified of an incoming call.
//        /// </remarks>
//        /// <returns>
//        /// Returns the parsed SIP response received with a 200-OK response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the
//        ///             parameter contains invalid or restricted signaling headers, or when 
//        ///            the call is used as a third party call controller with custom MIME parts or with early media support.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the call is not in a valid state to perform this operation or does not have valid media provider to bind to.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData> EstablishAsync(this Microsoft.Rtc.Collaboration.InstantMessagingCall source, Microsoft.Rtc.Collaboration.ToastMessage toastMessage, Microsoft.Rtc.Collaboration.CallEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.CallMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, toastMessage, options, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to report that a message was not delivered to its final destination.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageId">
//        /// Identifies the message.
//        /// </param>
//        /// <param name="responseCode">
//        /// The response code for this delivery notification.
//        /// </param>
//        /// <remarks>
//        /// This method should be called only by the applications that do not directly consume message but serve
//        /// as proxy (like Communicator Web Access) for delivering the received message to a remote entity.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when flow configured for
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same instance of asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task SendFailureDeliveryNotificationAsync(this Microsoft.Rtc.Collaboration.InstantMessagingFlow source, Microsoft.Rtc.Collaboration.InstantMessageId messageId, int responseCode)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSendFailureDeliveryNotification, source.EndSendFailureDeliveryNotification, messageId, responseCode, null);
//        }
        
//        /// <summary>
//        /// Send an instant message in the conversation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contentType">
//        /// The content type.
//        /// </param>
//        /// <param name="body">
//        /// The message body.
//        /// </param>
//        /// <remarks>
//        /// It is delivered to all remote participants currently
//        /// capable of receiving instant messages.
//        /// </remarks>
//        /// <returns>
//        /// The message id from the provisional response, if any, received Or the list of participants failed to receive the message.
//        /// By default, the message id will not be populated unless the application configured the flow property WaitingForDeliveryNotificationDisabled appropriately.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is passed for a required parameter. The parameter
//        ///            name that is required is included in the exception message.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the provider is in invalid state to send a message.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same instance of asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error response. 
//        ///            The SipResponseData in the exception should give additional information.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ServerPolicyException">
//        /// A server policy setting does not allow the sending of the message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out while waiting for a response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.SendInstantMessageResult> SendInstantMessageAsync(this Microsoft.Rtc.Collaboration.InstantMessagingFlow source, System.Net.Mime.ContentType contentType, byte[] body)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.SendInstantMessageResult>.Factory.FromAsync(source.BeginSendInstantMessage, source.EndSendInstantMessage, contentType, body, null);
//        }
        
//        /// <summary>
//        /// Send a text message in the conversation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="textBody">
//        /// Text body.
//        /// </param>
//        /// <remarks>
//        /// It is delivered to all remote participants currently
//        /// capable of receiving instant messages.
//        /// </remarks>
//        /// <returns>
//        /// The message id from the provisional response, if any, received Or the list of participants failed to receive the message.
//        /// By default, the message id will not be populated unless the application configured the flow property WaitingForDeliveryNotificationDisabled appropriately.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is passed for a required parameter. The parameter
//        ///            name that is required is included in the exception message.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the provider is in the invalid state to send a message.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same instance of asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error response. 
//        ///            The SipResponseData in the exception should give additional information.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ServerPolicyException">
//        /// A server policy setting does not allow the sending of the message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out while waiting for a response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.SendInstantMessageResult> SendInstantMessageAsync(this Microsoft.Rtc.Collaboration.InstantMessagingFlow source, string textBody)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.SendInstantMessageResult>.Factory.FromAsync(source.BeginSendInstantMessage, source.EndSendInstantMessage, textBody, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to report that a message was successfully delivered to its final destination.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageId">
//        /// Identifies the message.
//        /// </param>
//        /// <remarks>
//        /// This method should be called only by the applications that do not directly consume message but serve
//        /// as proxy (like Communicator Web Access) for delivering the received message to a remote entity.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when flowSetting is configured for
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same instance of asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task SendSuccessDeliveryNotificationAsync(this Microsoft.Rtc.Collaboration.InstantMessagingFlow source, Microsoft.Rtc.Collaboration.InstantMessageId messageId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSendSuccessDeliveryNotification, source.EndSendSuccessDeliveryNotification, messageId, null);
//        }
        
//        /// <summary>
//        /// Requests from the Instant Messaging MCU to initiate an Instant Messaging call to the supplied destination URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="destinationUri">
//        /// The URI of the entity to call.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied destinationUri is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied destinationUri is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task DialOutAsync(this Microsoft.Rtc.Collaboration.InstantMessagingMcuSession source, string destinationUri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDialOut, source.EndDialOut, destinationUri, null);
//        }
        
//        /// <summary>
//        /// Sends a command to focus.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="command">
//        /// The command to send.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the command to be sent. Could be null.
//        /// </param>
//        /// <returns>
//        /// The basic parsed response.
//        /// </returns>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceCommandResponse> SendCommandAsync(this Microsoft.Rtc.Internal.Collaboration.Conferencing.InternalConferenceSession source, Microsoft.Rtc.Internal.Collaboration.Conferencing.Commands.ConferenceCommand command, Microsoft.Rtc.Collaboration.ConferenceCommandOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.ConferenceCommandResponse>.Factory.FromAsync(source.BeginSendCommand, source.EndSendCommand, command, options, null);
//        }
        
//        /// <summary>
//        /// DO NOT USE THIS METHOD.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participantUri">
//        /// 
//        /// </param>
//        /// <param name="granted">
//        /// 
//        /// </param>
//        public static System.Threading.Tasks.Task SetUserAccessAsync(this Microsoft.Rtc.Internal.Collaboration.Conferencing.InternalConferenceSession source, string participantUri, bool granted)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSetUserAccess, source.EndSetUserAccess, participantUri, granted, null);
//        }
        
//        /// <summary>
//        /// Admits lobby participants into the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="lobbyParticipants">
//        /// A list of the lobby participants to admit into the conference.
//        /// </param>
//        /// <remarks>
//        /// Only conference leaders are allowed to perform this operation.
//        /// </remarks>
//        /// <returns>
//        /// A response to the command indicating with participants were successfully admitted into the lobby and those participants who were not including the failure reason.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is set to null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an empty collection or contains a null member.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation times out while waiting for a response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when admitting the participants failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when admitting participant\s failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse> AdmitLobbyParticipantsAsync(this Microsoft.Rtc.Collaboration.LobbyManager source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.ConversationParticipant> lobbyParticipants)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse>.Factory.FromAsync(source.BeginAdmitLobbyParticipants, source.EndAdmitLobbyParticipants, lobbyParticipants, null);
//        }
        
//        /// <summary>
//        /// Admits lobby participants into the conference.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="lobbyParticipants">
//        /// A list of the lobby participants to admit into the conference.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize admitting lobby participants. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// Only conference leaders are allowed to perform this operation.
//        /// </remarks>
//        /// <returns>
//        /// A response to the command indicating with participants were successfully admitted into the lobby and those participants who were not including the failure reason.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is set to null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an empty collection or contains a null member.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation times out while waiting for a response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when admitting the participants failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when admitting participant\s failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse> AdmitLobbyParticipantsAsync(this Microsoft.Rtc.Collaboration.LobbyManager source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.ConversationParticipant> lobbyParticipants, Microsoft.Rtc.Collaboration.LobbyAdmitOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse>.Factory.FromAsync(source.BeginAdmitLobbyParticipants, source.EndAdmitLobbyParticipants, lobbyParticipants, options, null);
//        }
        
//        /// <summary>
//        /// Denies lobby participants admission into conference and removes them from the lobby.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="lobbyParticipants">
//        /// A list of lobby participants to remove from the lobby.
//        /// </param>
//        /// <remarks>
//        /// Only conference leaders can perform this operation.
//        /// </remarks>
//        /// <returns>
//        /// A response to the command indicating with participants were successfully denied access into the conference and those participants who were not successfully denied including the failure reason.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  is set to null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  is an empty list.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation times out while waiting for a response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when admitting the participants failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when admitting participant\s failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse> DenyLobbyParticipantsAsync(this Microsoft.Rtc.Collaboration.LobbyManager source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.ConversationParticipant> lobbyParticipants)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse>.Factory.FromAsync(source.BeginDenyLobbyParticipants, source.EndDenyLobbyParticipants, lobbyParticipants, null);
//        }
        
//        /// <summary>
//        /// Denies lobby participants admission into conference and removes them from the lobby.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="lobbyParticipants">
//        /// A list of lobby participants to remove from the lobby.
//        /// </param>
//        /// <param name="options">
//        /// Options to denying participants admission into the conference. Could be set to null.
//        /// </param>
//        /// <remarks>
//        /// Only conference leaders can perform this operation.
//        /// </remarks>
//        /// <returns>
//        /// A response to the command indicating with participants were successfully denied access into the conference and those participants who were not successfully denied including the failure reason.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the operation is not valid at the given conference session state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  is set to null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  is an empty list.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation times out while waiting for a response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when admitting the participants failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when admitting participant\s failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse> DenyLobbyParticipantsAsync(this Microsoft.Rtc.Collaboration.LobbyManager source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.ConversationParticipant> lobbyParticipants, Microsoft.Rtc.Collaboration.LobbyDenyOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.LobbyOperationResponse>.Factory.FromAsync(source.BeginDenyLobbyParticipants, source.EndDenyLobbyParticipants, lobbyParticipants, options, null);
//        }
        
//        /// <summary>
//        /// Establishes the endpoint so that it can receive incoming calls and conference invitations.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Registration, querying for in-band provisioning data, getting Media Relay Tokens, and automatic presence publication and subscription
//        /// are some of the operations performed during endpoint establishment. For ApplicationEndpoints all the operations
//        /// are optional while for UserEndpoints the last two operations are optional.
//        /// </remarks>
//        /// <returns>
//        /// The SIP response from the operation.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the platform or endpoint is not correct for this operation.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when endpoint is in invalid state be established or if retrieval of in-band provisioning data fails.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RegisterException">
//        /// Thrown when the Register operation failed with the message text indicating the reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.AuthenticationException">
//        /// Thrown when a general authentication-related problem occurred.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when server did not respond to Register request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> EstablishAsync(this Microsoft.Rtc.Collaboration.LocalEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, null);
//        }
        
//        /// <summary>
//        /// Establishes the endpoint so that it can receive incoming calls and conference invitations.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="additionalHeaders">
//        /// Collection of signaling headers to be included with Register request. Can be null.
//        /// </param>
//        /// <remarks>
//        /// Registration, querying for in-band provisioning data, getting Media Relay Tokens, and automatic presence publication and subscription
//        /// are some of the operations performed during endpoint establishment. For ApplicationEndpoints all the operations
//        /// are optional while for UserEndpoints the last two operations are optional.
//        /// </remarks>
//        /// <returns>
//        /// The SIP response from the operation.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the platform or endpoint is not right for this operation
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when one of the additional headers is a restricted header.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when endpoint is in invalid state be established or if retrieval of in-band provisioning data fails.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RegisterException">
//        /// Thrown when the Register operation failed with the message text indicating the reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.AuthenticationException">
//        /// Thrown when a general authentication-related problem occurred.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when server did not respond to Register request.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> EstablishAsync(this Microsoft.Rtc.Collaboration.LocalEndpoint source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> additionalHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, additionalHeaders, null);
//        }
        
//        /// <summary>
//        /// Queries the latest provisioning data (advanced).
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Normally, an application can retrieve the cached ProvisioningData value from
//        /// the endpoint using the  method. The cache is renewed periodically. The application should use this
//        /// method when it believes that the cached provisioning data is stale or empty. Unlike other methods on the endpoint
//        /// this method can be invoked even without establishing the endpoint.
//        /// </remarks>
//        /// <returns>
//        /// The provisioning data corresponding to the URI of the endpoint.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the object is not in correct state to refresh provisioning data.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when a bad notification message is encountered.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when this operation failed for other reasons.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Presence.ProvisioningData> GetProvisioningDataAsync(this Microsoft.Rtc.Collaboration.LocalEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.Presence.ProvisioningData>.Factory.FromAsync(source.BeginGetProvisioningData, source.EndGetProvisioningData, null);
//        }
        
//        /// <summary>
//        /// Terminates the local endpoint after cleaning up all communication and collaboration resources.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// The local endpoint is no longer usable after this operation is invoked.
//        /// 
//        /// Note that this operation never throws.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.LocalEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Begins a presence query request for a given list of targets for the given set of presence categories.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="targets">
//        /// The list of target addresses for the query.
//        /// </param>
//        /// <param name="categories">
//        /// The list of presence categories for the query. Categories that can be set are "contactCard", "note", "state", "services", and "calendarData".
//        /// </param>
//        /// <param name="queryResultHandler">
//        /// EventHandler to be invoked as results become available. This value can be null.
//        /// </param>
//        /// <remarks>
//        /// A presence query internally can involve multiple query requests to different single and pool targets.
//        /// If the user specified a query result handler, then results will be notified on the given event handler
//        /// as soon as they are available.
//        /// Calling EndPresenceQuery will return all results for the query.
//        /// </remarks>
//        /// <returns>
//        /// The list of presence notifications for the targets.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an empty collection, or when it contains a null member, or when there are no new targets to be added or removed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndPresenceQuery was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.Presence.RemotePresentityNotification>> PresenceQueryAsync(this Microsoft.Rtc.Collaboration.LocalEndpointPresenceServices source, System.Collections.Generic.IEnumerable<string> targets, string[] categories, System.EventHandler<Microsoft.Rtc.Collaboration.Presence.RemotePresentitiesNotificationEventArgs> queryResultHandler)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.Presence.RemotePresentityNotification>>.Factory.FromAsync(source.BeginPresenceQuery, source.EndPresenceQuery, targets, categories, queryResultHandler, null);
//        }
        
//        /// <summary>
//        /// Begins the asynchronous operation to refresh all views that were created out of this endpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This is an expensive operation and applications are advised to use the API sparingly.
//        /// </remarks>
//        public static System.Threading.Tasks.Task RefreshRemotePresenceViewsAsync(this Microsoft.Rtc.Collaboration.LocalEndpointPresenceServices source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRefreshRemotePresenceViews, source.EndRefreshRemotePresenceViews, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to acknowledge a subscriber.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="subscriberId">
//        /// The subscriber to acknowledge.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is empty.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task AcknowledgeSubscriberAsync(this Microsoft.Rtc.Collaboration.Presence.LocalOwnerPresence source, string subscriberId)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAcknowledgeSubscriber, source.EndAcknowledgeSubscriber, subscriberId, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to delete the given list of categories.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="categories">
//        /// The list of categories to be deleted.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  contains a null CategoryItem.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result or when the result is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task DeletePresenceAsync(this Microsoft.Rtc.Collaboration.Presence.LocalOwnerPresence source, System.Collections.Generic.ICollection<Microsoft.Rtc.Collaboration.Presence.PresenceCategoryWithMetaData> categories)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDeletePresence, source.EndDeletePresence, categories, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to delete the given list of categories.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="categoryItems">
//        /// The list of categoryItems to be deleted.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state, or when the endpoint is an application endpoint and there is an unknown category.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  contains a null CategoryItem or the instance id of a category in  could not be determined.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result or when the result is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task DeletePresenceAsync(this Microsoft.Rtc.Collaboration.Presence.LocalOwnerPresence source, System.Collections.Generic.ICollection<Microsoft.Rtc.Collaboration.Presence.PresenceCategory> categoryItems)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDeletePresence, source.EndDeletePresence, categoryItems, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to publish a given list of categories.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="categories">
//        /// The list of categories to be published.
//        /// </param>
//        /// <remarks>
//        /// If a version conflict error occurred in publishing categories, it will automatically retried with updated version number.
//        /// 
//        /// Deleting a publication involves publishing the  object again with the
//        /// set to  and
//        /// set to the value zero.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  contains a null CategoryItem.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the publish operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task PublishPresenceAsync(this Microsoft.Rtc.Collaboration.Presence.LocalOwnerPresence source, System.Collections.Generic.ICollection<Microsoft.Rtc.Collaboration.Presence.PresenceCategoryWithMetaData> categories)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginPublishPresence, source.EndPublishPresence, categories, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to publish a given list of categories.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="categoryItems">
//        /// The list of  to be published.
//        /// </param>
//        /// <remarks>
//        /// If a version conflict error occurs while publishing categories, the operation will automatically be retried with an updated version number.
//        /// Any user manifest publications will be honored.
//        /// 
//        /// Only UserEndpoints can use this API which uses a grammar provided by UCMA to publish. ApplicationEndpoints have
//        /// to explicitly specify the container ID and instance ID for their publication.
//        /// 
//        /// UserEndpoints must already have subscribed to  session before they can use this Api.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state, or the current state of  is not "subscribed" or atleast one of the categories to be published is unknown.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  passed is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  contains a null CategoryItem or a custom category with invalid xml or transformation.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the publish operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task PublishPresenceAsync(this Microsoft.Rtc.Collaboration.Presence.LocalOwnerPresence source, System.Collections.Generic.ICollection<Microsoft.Rtc.Collaboration.Presence.PresenceCategory> categoryItems)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginPublishPresence, source.EndPublishPresence, categoryItems, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to update the container memberships.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="operations">
//        /// The list of container update operations.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  contains a null .
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the publish operation or an empty container update operation is specified.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdateContainerMembershipAsync(this Microsoft.Rtc.Collaboration.Presence.LocalOwnerPresence source, System.Collections.Generic.ICollection<Microsoft.Rtc.Collaboration.Presence.ContainerUpdateOperation> operations)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdateContainerMembership, source.EndUpdateContainerMembership, operations, null);
//        }
        
//        /// <summary>
//        /// Ejects a participant from the MCU.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participant">
//        /// The participant to eject.
//        /// </param>
//        /// <remarks>
//        /// The parent ConferenceSession has to be connected to a conference that supports the corresponding MCU type.
//        /// 
//        /// The operation times out if no response was received within three minutes. If a pending response was received,
//        /// the wait period is reset back to three minutes.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied participant is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EjectAsync(this Microsoft.Rtc.Collaboration.McuSession source, Microsoft.Rtc.Collaboration.ConversationParticipant participant)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEject, source.EndEject, participant, null);
//        }
        
//        /// <summary>
//        /// Ejects a participant from the MCU.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="participant">
//        /// The participant to eject.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the operation. Could be null.
//        /// </param>
//        /// <remarks>
//        /// The parent ConferenceSession has to be connected to a conference that supports the corresponding MCU type.
//        /// 
//        /// The operation times out if no response was received within three minutes. If a pending response was received,
//        /// the wait period is reset back to three minutes.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied participant is null.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EjectAsync(this Microsoft.Rtc.Collaboration.McuSession source, Microsoft.Rtc.Collaboration.ConversationParticipant participant, Microsoft.Rtc.Collaboration.EjectOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEject, source.EndEject, participant, options, null);
//        }
        
//        /// <summary>
//        /// Ejects a participant or an endpoint from the MCU based on the supplied URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="uri">
//        /// The URI of the participant or endpoint to eject.
//        /// </param>
//        /// <remarks>
//        /// The parent ConferenceSession has to be connected to a conference that supports the corresponding MCU type.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied URI is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied URI is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EjectAsync(this Microsoft.Rtc.Collaboration.McuSession source, string uri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEject, source.EndEject, uri, null);
//        }
        
//        /// <summary>
//        /// Ejects a participant or an endpoint from the MCU based on the supplied URI.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="uri">
//        /// The URI of the participant or endpoint to eject.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the eject operation. Could be null.
//        /// </param>
//        /// <remarks>
//        /// The parent ConferenceSession has to be connected to a conference that supports the corresponding MCU type.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the parent ConferenceSession is not in a valid state or the conference does not support the corresponding MCU type.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the supplied URI is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the supplied URI is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when the parent ConferenceSession is reconnecting (FailureReason will be set to InvalidOperationReason.RetryableOperation).
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the operation timed out waiting for a reply.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.ConferenceFailureException">
//        /// Thrown when the operation failed with a Centralized Conference Control Protocol (C3P) body in the response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed without a C3P body in the response.
//        /// </exception>
//        public static System.Threading.Tasks.Task EjectAsync(this Microsoft.Rtc.Collaboration.McuSession source, string uri, Microsoft.Rtc.Collaboration.EjectOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEject, source.EndEject, uri, options, null);
//        }
        
//        /// <summary>
//        /// Initiate an operation to send quality of experience (QoE) metrics to the server
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="qoeGruu">
//        /// Target of the QoE metrics
//        /// </param>
//        /// <param name="call">
//        /// The current Call
//        /// </param>
//        /// <param name="qoeData">
//        /// QoE content, as byte array, that needs to be published
//        /// </param>
//        /// <returns>
//        /// SipResponse for the SERVICE request or null when begin operation did not send out a SERVICE request.
//        /// </returns>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendQoEMetricsInternalAsync(this Microsoft.Rtc.Internal.Collaboration.ComponentModel.MediaProviderInternal source, string qoeGruu, Microsoft.Rtc.Collaboration.Call call, byte[] qoeData)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendQoEMetricsInternal, source.EndSendQoEMetricsInternal, qoeGruu, call, qoeData, null);
//        }
        
//        /// <summary>
//        /// Start the service request to receive the MediaRelay tokens.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="requestList">
//        /// List of request data to be sent with request.
//        /// </param>
//        /// <returns>
//        /// Return the Enumerable collection containing the tokens returned by server.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not registered.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when requestList is empty or contains null member in list.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Throw when the endpoint is not in a valid state to make this request.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when endSendMessage is called multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when a non-null is expected for an argument.  The argument name for which a 
//        ///            non-null is expected is part of the exception message
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<System.Collections.ObjectModel.Collection<Microsoft.Rtc.Internal.Collaboration.MediaRelayToken>> GetMediaRelayTokensAsync(this Microsoft.Rtc.Internal.Collaboration.MediaRelayTokenRequest source, System.Collections.Generic.ICollection<Microsoft.Rtc.Internal.Collaboration.MediaRelayTokenRequestData> requestList)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<System.Collections.ObjectModel.Collection<Microsoft.Rtc.Internal.Collaboration.MediaRelayToken>>.Factory.FromAsync(source.BeginGetMediaRelayTokens, source.EndGetMediaRelayTokens, requestList, null);
//        }
        
//        /// <summary>
//        /// Establishes a media session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the media session is not in valid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishAsync(this Microsoft.Rtc.Internal.Collaboration.MediaSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, null);
//        }
        
//        /// <summary>
//        /// Establishes a media session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to establish a media session.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the media session is not in valid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task EstablishAsync(this Microsoft.Rtc.Internal.Collaboration.MediaSession source, Microsoft.Rtc.Internal.Collaboration.MediaSessionEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, options, null);
//        }
        
//        /// <summary>
//        /// Terminates a media session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Internal.Collaboration.MediaSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Prepares the media source.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="mode">
//        /// The open mode.
//        /// </param>
//        /// <remarks>
//        /// An application must call this method before any Player begins playing a MediaSource.
//        /// The application must also call EndPrepareSource.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the mode argument is not a value in the MediaSourceOpenMode enumerated type.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the audio/video platform is not initialized.
//        /// </exception>
//        public static System.Threading.Tasks.Task PrepareSourceAsync(this Microsoft.Rtc.Collaboration.AudioVideo.MediaSource source, Microsoft.Rtc.Collaboration.AudioVideo.MediaSourceOpenMode mode)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginPrepareSource, source.EndPrepareSource, mode, null);
//        }
        
//        /// <summary>
//        /// Accepts the offer and triggers IOfferAnswer.GetAnswer calls to send the answer.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The signaling headers to use in the response. Can be null.
//        /// </param>
//        /// <remarks>
//        /// The application can call this method when it is ready with the answer for the offer
//        /// represented in this event arg.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when final response has already been sent.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the response cannot be sent for other reasons.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when ack is not received.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when an incorrect result instance is passed.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData> AcceptAsync(this Microsoft.Rtc.Signaling.OfferInReInviteEventArgs source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData>.Factory.FromAsync(source.BeginAccept, source.EndAccept, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Decline the offer with a specific reason. The operation will complete when
//        /// the ACK message is received.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The response code to decline with.
//        /// </param>
//        /// <param name="reasonPhrase">
//        /// The reason phrase to use. Can be null.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The signaling headers to use in the response. Can be null.
//        /// </param>
//        /// <param name="contentType">
//        /// The content type of the body. Can be null if body is null.
//        /// </param>
//        /// <param name="body">
//        /// The body to send.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when called in an invalid state or a final response has already been sent.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// The response code is not in the range expected.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when there are problems with arguments supplied.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the response cannot be sent for other reasons.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the response cannot be sent for other reasons.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when ack is not received.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData> DeclineAsync(this Microsoft.Rtc.Signaling.OfferInReInviteEventArgs source, int responseCode, string reasonPhrase, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders, System.Net.Mime.ContentType contentType, byte[] body)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData>.Factory.FromAsync(source.BeginDecline(responseCode, reasonPhrase, signalingHeaders, contentType, body, null, null), source.EndDecline);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to refresh the underlying subscription.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked before the subscription is established.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task RefreshAsync(this Microsoft.Rtc.Collaboration.Presence.PublishSubscribeSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRefresh, source.EndRefresh, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to subscribe to the presence session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// UCMA allows subscription to be reused. Hence, the application can re-subscribe to the same subscription
//        /// after it has been unsubscribed.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the subscription is not in a valid state.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the endpoint or session is in an invalid state during the operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task SubscribeAsync(this Microsoft.Rtc.Collaboration.Presence.PublishSubscribeSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSubscribe, source.EndSubscribe, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to unsubscribe the underlying subscription.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// If no underlying subscription exists, then this operation completes immediately.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task UnsubscribeAsync(this Microsoft.Rtc.Collaboration.Presence.PublishSubscribeSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUnsubscribe, source.EndUnsubscribe, null);
//        }
        
//        /// <summary>
//        /// Sends a message to another endpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageType">
//        /// The message type.
//        /// </param>
//        /// <param name="sessionTarget">
//        /// Target to send the message.
//        /// </param>
//        /// <param name="contentType">
//        /// Content type describing the body. If null the body must be null. If no encoding is specified, UTF8 is assumed.
//        /// </param>
//        /// <param name="body">
//        /// The body for the data.
//        /// </param>
//        /// <returns>
//        /// The response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when arguments are null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error.  The response code in
//        ///            the exception should give more information about the error.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendMessageAsync(this Microsoft.Rtc.Signaling.RealTimeEndpoint source, Microsoft.Rtc.Signaling.MessageType messageType, Microsoft.Rtc.Signaling.RealTimeAddress sessionTarget, System.Net.Mime.ContentType contentType, byte[] body)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendMessage(messageType, sessionTarget, contentType, body, null, null), source.EndSendMessage);
//        }
        
//        /// <summary>
//        /// Sends a message.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageType">
//        /// The message type.
//        /// </param>
//        /// <param name="sessionTarget">
//        /// Target to send the message.
//        /// </param>
//        /// <param name="options">
//        /// Options to customize the behavior of send message.
//        /// </param>
//        /// <returns>
//        /// The response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if one of the SignalingHeader in signalingHeaders collection have null or restricted header.
//        /// </exception>
//        /// <exception cref="T:System.NotSupportedException">
//        /// Attempting to specify a connection context sending a message on a SipEndpoint.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error.  The response code in
//        ///            the exception should give more information about the error.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendMessageAsync(this Microsoft.Rtc.Signaling.RealTimeEndpoint source, Microsoft.Rtc.Signaling.MessageType messageType, Microsoft.Rtc.Signaling.RealTimeAddress sessionTarget, Microsoft.Rtc.Signaling.SendMessageOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendMessage, source.EndSendMessage, messageType, sessionTarget, options, null);
//        }
        
//        /// <summary>
//        /// Sends a message.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageType">
//        /// The message type.
//        /// </param>
//        /// <param name="sessionTarget">
//        /// Target to send the message.
//        /// </param>
//        /// <param name="contentType">
//        /// Content type describing the body. If null text/plain, UTF-8 is assumed.
//        /// </param>
//        /// <param name="body">
//        /// The body for the data.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The headers provided for this message. Can be null.
//        /// </param>
//        /// <returns>
//        /// The response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if one of the SignalingHeader in signalingHeaders collection have null or restricted header.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error.  The response code in
//        ///            the exception should give more information about the error.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendMessageAsync(this Microsoft.Rtc.Signaling.RealTimeEndpoint source, Microsoft.Rtc.Signaling.MessageType messageType, Microsoft.Rtc.Signaling.RealTimeAddress sessionTarget, System.Net.Mime.ContentType contentType, byte[] body, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendMessage(messageType, sessionTarget, contentType, body, signalingHeaders, null, null), source.EndSendMessage);
//        }
        
//        /// <summary>
//        /// Terminates the endpoint and cleans up active sessions and resources.
//        /// The endpoint is no longer usable.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Signaling.RealTimeEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Starts listening on default addresses on the specified port.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="port">
//        /// The port that should be used for all addresses.
//        /// </param>
//        /// <remarks>
//        /// If 0 is passed for port, a port is randomly chosen and attempted. An exception may be raised if the same port
//        /// is not available on all interfaces. This is generally useful only in testing when two applications are in the same process.
//        /// It is recommended that an explicit port be chosen instead of 0. The address and port
//        /// need to be known and configured by other applications in order to communicate. This is not practical when it is randomly chosen.
//        /// </remarks>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ConnectionFailureException">
//        /// The address and port are already in use. Inner exception will contain the socket exception and error code.
//        /// </exception>
//        public static System.Threading.Tasks.Task StartListeningAsync(this Microsoft.Rtc.Signaling.RealTimeServerConnectionManager source, int port)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginStartListening, source.EndStartListening, port, null);
//        }
        
//        /// <summary>
//        /// Starts listening on default addresses on the specified port.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="port">
//        /// The port that should be used for all addresses.
//        /// </param>
//        /// <param name="addresses">
//        /// A list of addresses to listen on, or null to listen on all available addresses.
//        /// </param>
//        /// <param name="options">
//        /// Options to use, or null to use the defaults.
//        /// </param>
//        /// <remarks>
//        /// If 0 is passed for port, a port is randomly chosen and attempted. An exception may be raised if the same port
//        /// is not available on all interfaces. This is generally useful only in testing when two applications are in the same process.
//        /// It is recommended that an explicit port be chosen instead of 0. The address and port
//        /// need to be known and configured by other applications in order to communicate. This is not practical when it is randomly chosen.
//        /// </remarks>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ConnectionFailureException">
//        /// The address and port are already in use. Inner exception will contain the socket exception and error code.
//        /// </exception>
//        public static System.Threading.Tasks.Task StartListeningAsync(this Microsoft.Rtc.Signaling.RealTimeServerConnectionManager source, int port, System.Collections.Generic.IEnumerable<System.Net.IPAddress> addresses, Microsoft.Rtc.Signaling.StartListeningOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginStartListening, source.EndStartListening, port, addresses, options, null);
//        }
        
//        /// <summary>
//        /// Starts an operation to stop listening on all addresses.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This overload stops listening on all addresses.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint never listened or already stopped listening.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the endpoint stopped listening and timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when the operation failed.
//        /// </exception>
//        public static System.Threading.Tasks.Task StopListeningAsync(this Microsoft.Rtc.Signaling.RealTimeServerConnectionManager source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginStopListening, source.EndStopListening, null);
//        }
        
//        /// <summary>
//        /// Sets the Refer state. This will result in sending Notification to the referrer.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The specific response code
//        /// </param>
//        /// <param name="responseText">
//        /// The response text. Can be null.
//        /// </param>
//        /// <param name="remainingSipFragment">
//        /// The remaining SIP fragment
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is already terminated or when the refer state transition is not allowed
//        /// </exception>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the response code is out of range.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task SetStateAsync(this Microsoft.Rtc.Signaling.ReferNotifier source, int responseCode, string responseText, string remainingSipFragment)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSetState, source.EndSetState, responseCode, responseText, remainingSipFragment, null);
//        }
        
//        /// <summary>
//        /// Sets the Refer state. This will result in sending Notification to the referrer.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="referState">
//        /// The refer State value to set
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is not in a valid session state to set the refer state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task SetStateAsync(this Microsoft.Rtc.Signaling.ReferNotifier source, Microsoft.Rtc.Signaling.ReferState referState)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSetState, source.EndSetState, referState, null);
//        }
        
//        /// <summary>
//        /// Terminates this refer subscription. The subscription is active until terminating Notify message is received.
//        /// If the application is not interested in waiting for the notification messages, this method can be used to terminate
//        /// the underlying subscription for these notification messages. The refer state will not be affected by this operation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// Returns the response data associated the unsubscribe request.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> TerminateSubscriptionAsync(this Microsoft.Rtc.Signaling.ReferStatus source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginTerminateSubscription, source.EndTerminateSubscription, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to add a target in the subscription dispatcher and to start the subscription for the given target.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="targetsToAdd">
//        /// The addresses of the targets to add.
//        /// </param>
//        /// <remarks>
//        /// This  will return immediately. The application should use the
//        /// event handler to track whether the individual targets have been subscribed to.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an empty collection, or when it contains a null member, or when there are no new targets to be added or removed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndAddTargets was called more than once for the same instance of result.
//        /// </exception>
//        public static System.Threading.Tasks.Task AddTargetsAsync(this Microsoft.Rtc.Collaboration.Presence.RemotePresence source, System.Collections.Generic.ICollection<Microsoft.Rtc.Collaboration.Presence.RemotePresentitySubscriptionTarget> targetsToAdd)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAddTargets, source.EndAddTargets, targetsToAdd, null);
//        }
        
//        /// <summary>
//        /// Begins a presence query request for a given list of targets for the given set of presence categories.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="targets">
//        /// The list of target addresses for the query.
//        /// </param>
//        /// <param name="categories">
//        /// The list of presence categories for the query. Categories that can be set are "contactCard", "note", "state", "services", and "calendarData".
//        /// </param>
//        /// <param name="queryResultHandler">
//        /// EventHandler to be invoked as results become available. This value can be null.
//        /// </param>
//        /// <remarks>
//        /// A presence query internally can involve multiple query requests to different single and pool targets.
//        /// If the user specified a query result handler, then results will be notified on the given event handler
//        /// as soon as they are available.
//        /// Calling EndPresenceQuery will return all results for the query.
//        /// </remarks>
//        /// <returns>
//        /// The list of presence notifications for the targets.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an empty collection, or when it contains a null member, or when there are no new targets to be added or removed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndPresenceQuery was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.Presence.RemotePresentityNotificationData>> PresenceQueryAsync(this Microsoft.Rtc.Collaboration.Presence.RemotePresence source, System.Collections.Generic.IEnumerable<string> targets, string[] categories, System.EventHandler<Microsoft.Rtc.Collaboration.Presence.RemotePresenceNotificationEventArgs> queryResultHandler)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.Rtc.Collaboration.Presence.RemotePresentityNotificationData>>.Factory.FromAsync(source.BeginPresenceQuery, source.EndPresenceQuery, targets, categories, queryResultHandler, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to refresh the notifications.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when no active presentity is in PresenceView.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndRefresh was called more than once for the same instance of result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task RefreshAsync(this Microsoft.Rtc.Collaboration.Presence.RemotePresence source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRefresh, source.EndRefresh, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to unsubscribe to all existing subscriptions that are not already terminating.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This Api is now obsolete, please use StartUnsubscribingToAllPresentities instead.
//        /// </remarks>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndRemoveAllTargets was called more than once for the same instance of result.
//        /// </exception>
//        public static System.Threading.Tasks.Task RemoveAllTargetsAsync(this Microsoft.Rtc.Collaboration.Presence.RemotePresence source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRemoveAllTargets, source.EndRemoveAllTargets, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to unsubscribe to a target.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="uri">
//        /// The URI of the target to remove.
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is an invalid sip URI or a subscription does not exist for this target.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndRemoveTarget was called more than once for the same instance of result.
//        /// </exception>
//        public static System.Threading.Tasks.Task RemoveTargetAsync(this Microsoft.Rtc.Collaboration.Presence.RemotePresence source, string uri)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRemoveTarget, source.EndRemoveTarget, uri, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to dispose this view.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Collaboration.Presence.RemotePresenceView source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Accept the session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// Returns SIP message (200 response or ACK request)
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the session does not allow the operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> AcceptAsync(this Microsoft.Rtc.Signaling.SignalingSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginAccept, source.EndAccept, null);
//        }
        
//        /// <summary>
//        /// Accept the session with options specified.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to customize the accept behavior.
//        /// </param>
//        /// <returns>
//        /// Returns SIP message (200 response or ACK request)
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the session does not allow the operation or the dialog context
//        ///            has been used in a previous transaction.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> AcceptAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.SignalingSessionAcceptOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginAccept, source.EndAccept, options, null);
//        }
        
//        /// <summary>
//        /// Establish the session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// Returns SIP message (200 response or ACK request)
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the session does not allow the operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> EstablishAsync(this Microsoft.Rtc.Signaling.SignalingSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, null);
//        }
        
//        /// <summary>
//        /// Establish the session with options specified.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to customize the establish behavior.
//        /// </param>
//        /// <returns>
//        /// Returns SIP message (200 response or ACK request)
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the session does not allow the operation.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> EstablishAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.SignalingSessionEstablishOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginEstablish, source.EndEstablish, options, null);
//        }
        
//        /// <summary>
//        /// Participates in a session. This method needs to be called (for both outgoing and incoming messages)
//        /// to establish the session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// This method is now deprecated in favor of the BeginEstablish and BeginAccept APIs.
//        /// </remarks>
//        /// <returns>
//        /// Returns SIP message (200 response or ACK request)
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is not in a valid state to Participate.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when some other failure occurs.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> ParticipateAsync(this Microsoft.Rtc.Signaling.SignalingSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginParticipate, source.EndParticipate, null);
//        }
        
//        /// <summary>
//        /// Participates in a session. This method needs to be called (for both outgoing and incoming messages)
//        /// to establish the session.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The collection of signaling headers. Can be null.
//        /// </param>
//        /// <remarks>
//        /// This method is now deprecated in favor of the BeginEstablish and BeginAccept APIs.
//        /// </remarks>
//        /// <returns>
//        /// Returns SIP message (200 response or ACK request)
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is not in a valid state to Participate.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when some other failure occurs.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> ParticipateAsync(this Microsoft.Rtc.Signaling.SignalingSession source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginParticipate, source.EndParticipate, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Refers a URI to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="referTarget">
//        /// The Refer target URI.
//        /// </param>
//        /// <param name="referStatus">
//        /// The ReferStatus object provided by the caller to signal Refer state changes.
//        /// </param>
//        /// <remarks>
//        /// The platform supports multiple Refer operations at the same time. Some clients may
//        /// not support parallel Refer operations. Until the first notification is received,
//        /// the capability of the remote client is not known. For this reason, the first Refer
//        /// operation is special in the sense the subsequent Refer operations are queued until
//        /// first notify is received to learn the capability of the remote client. If the remote
//        /// supports parallel Refer operations, the queued Refer operations are all released.
//        /// If the remote does not support parallel Refer operations, the Refer operations are
//        /// carried out one at a time. When the terminating notify is received, the next Refer
//        /// operation is started. For this reason, calling synchronous method to send Refer or waiting
//        /// on the operation to complete (EndRefer) before the callback is called are highly discouraged.
//        /// </remarks>
//        /// <returns>
//        /// The response data received for the refer request.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is an invalid state to send a Refer.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when arguments are null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> ReferAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.RealTimeAddress referTarget, Microsoft.Rtc.Signaling.ReferStatus referStatus)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRefer, source.EndRefer, referTarget, referStatus, null);
//        }
        
//        /// <summary>
//        /// Refers a URI to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="referTarget">
//        /// RealTimeAddress that contains the refer URI
//        /// </param>
//        /// <param name="referStatus">
//        /// The refer status object provided by the caller to signal refer state change
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers required for this refer. Can be null.
//        /// </param>
//        /// <remarks>
//        /// The platform supports multiple Refer operations at the same time. Some clients may
//        /// not support parallel Refer operations. Until the first notification is received,
//        /// the capability of the remote client is not known. For this reason, the first Refer
//        /// operation is special in the sense the subsequent Refer operations are queued until
//        /// first notify is received to learn the capability of the remote client. If the remote
//        /// supports parallel Refer operations, the queued Refer operations are all released.
//        /// If the remote does not support parallel Refer operations, the Refer operations are
//        /// carried out one at a time. When the terminating notify is received, the next Refer
//        /// operation is started. For this reason, calling synchronous method to send Refer or waiting
//        /// on the operation to complete (EndRefer) before the callback is called are highly discouraged.
//        /// </remarks>
//        /// <returns>
//        /// The response data received for the refer request.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the refer status object is not Idle or is already used by another session.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when called in an invalid state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> ReferAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.RealTimeAddress referTarget, Microsoft.Rtc.Signaling.ReferStatus referStatus, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRefer, source.EndRefer, referTarget, referStatus, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Refers a URI to the remote participant.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="referTarget">
//        /// RealTimeAddress that contains the refer URI
//        /// </param>
//        /// <param name="referStatus">
//        /// The refer status object provided by the caller to signal refer state change
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers required for this refer. Can be null.
//        /// </param>
//        /// <param name="contentType">
//        /// Content type describing the body. Can be null if body is null.
//        /// </param>
//        /// <param name="body">
//        /// The body for the data. Can be null.
//        /// </param>
//        /// <remarks>
//        /// The platform supports multiple Refer operations at the same time. Some clients may
//        /// not support parallel Refer operations. Until the first notification is received,
//        /// the capability of the remote client is not known. For this reason, the first Refer
//        /// operation is special in the sense the subsequent Refer operations are queued until
//        /// first notify is received to learn the capability of the remote client. If the remote
//        /// supports parallel Refer operations, the queued Refer operations are all released.
//        /// If the remote does not support parallel Refer operations, the Refer operations are
//        /// carried out one at a time. When the terminating notify is received, the next Refer
//        /// operation is started. For this reason, calling synchronous method to send Refer or waiting
//        /// on the operation to complete (EndRefer) before the callback is called are highly discouraged.
//        /// </remarks>
//        /// <returns>
//        /// The response data received for the refer request.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the refer status object is not Idle or is already used by another session.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when called in an invalid state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> ReferAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.RealTimeAddress referTarget, Microsoft.Rtc.Signaling.ReferStatus referStatus, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders, System.Net.Mime.ContentType contentType, byte[] body)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRefer(referTarget, referStatus, signalingHeaders, contentType, body, null, null), source.EndRefer);
//        }
        
//        /// <summary>
//        /// Renegotiates the media description with the specified participant.
//        /// Only one negotiation can be outstanding with any participant at any time.
//        /// The participant should be part of the session for this method to succeed.
//        /// The participant cannot be a local participant.
//        /// A given topology may not allow the exchange of descriptions with certain participants.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers required for this renegotiate. Can be null.
//        /// </param>
//        /// <remarks>
//        /// In an early dialog, BeginRenegotiateDescription is intended to send only SDP-bearing messages.
//        /// As such, this method does not differentiate between a call to BeginRenegotiateDescription with a provided SDP session description
//        /// and a call without an SDP session description. Both will conflict with incoming SDP-bearing UPDATE messages.
//        /// </remarks>
//        /// <returns>
//        /// Returns the SIP response data associated with the operation.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when called in an invalid state, a renegotiate operation is already outstanding,
//        ///            or a null media description is specified via GetMediaOffer().
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when called in a temporary invalid state, and the operation can be retried.
//        /// </exception>
//        /// <exception cref="T:System.Exception">
//        /// Exceptions thrown by the application while generating media (interface IOfferAnswer) are not handled by the platform.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> RenegotiateDescriptionAsync(this Microsoft.Rtc.Signaling.SignalingSession source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRenegotiateDescription, source.EndRenegotiateDescription, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Renegotiates the media description.
//        /// Only one negotiation can be outstanding at any time.
//        /// The session should be in the Connected state for this method to work.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// In an early dialog, BeginRenegotiateDescription is intended to send only SDP-bearing messages.
//        /// As such, this method does not differentiate between a call to BeginRenegotiateDescription with a provided SDP session description
//        /// and a call without an SDP session description. Both will conflict with incoming SDP-bearing UPDATE messages.
//        /// </remarks>
//        /// <returns>
//        /// Returns the SIP response data associated with the operation.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is not in a valid state to renegotiate.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when called in a temporary invalid state, and the operation can be retried.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when there is no media description available.
//        /// </exception>
//        /// <exception cref="T:System.Exception">
//        /// Thrown by the application when generating media (interface IOfferAnswer) is not handled by the platform.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> RenegotiateDescriptionAsync(this Microsoft.Rtc.Signaling.SignalingSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRenegotiateDescription, source.EndRenegotiateDescription, null);
//        }
        
//        /// <summary>
//        /// Renegotiates the media description.
//        /// Only one negotiation can be outstanding at any time.
//        /// The session should be in the Connected state for this method to work.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="dialogContext">
//        /// The dialog to renegotiate on.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers to include in the renegotiation request. Can be null.
//        /// </param>
//        /// <remarks>
//        /// In an early dialog, BeginRenegotiateDescription is intended to send only SDP-bearing messages.
//        /// As such, this method does not differentiate between a call to BeginRenegotiateDescription with a provided SDP session description
//        /// and a call without an SDP session description. Both will conflict with incoming SDP-bearing UPDATE messages.
//        /// </remarks>
//        /// <returns>
//        /// Returns the SIP response data associated with the operation.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is not in a valid state to renegotiate or the dialog context
//        ///            has been used in a previous transaction.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when called in a temporary invalid state, and the operation can be retried.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when there is no media description available.
//        /// </exception>
//        /// <exception cref="T:System.Exception">
//        /// Thrown by the application when generating media (interface IOfferAnswer) is not handled by the platform.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> RenegotiateDescriptionAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.SipDialogContext dialogContext, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRenegotiateDescription, source.EndRenegotiateDescription, dialogContext, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Send message to participant specified. Participant who is not part of the session
//        /// is ignored.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageType">
//        /// Type of the body of the message
//        /// </param>
//        /// <param name="contentType">
//        /// Content type describing the body. Can be null if body is null and if null text/plain, UTF-8 is assumed.
//        /// </param>
//        /// <param name="body">
//        /// The body for the data. Can be null.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Headers provided for this invite. Can be null.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when a body is specified without a content type with media type. MessageType is
//        ///            not Message or Info.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when called in an invalid state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndSendMessage is called multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error. 
//        ///            The SipResponseData in the exception should give additional information.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when some other unknown errors occur.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ServerPolicyException">
//        /// A server policy setting does not allow the sending of the message.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendMessageAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.MessageType messageType, System.Net.Mime.ContentType contentType, byte[] body, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendMessage(messageType, contentType, body, signalingHeaders, null, null), source.EndSendMessage);
//        }
        
//        /// <summary>
//        /// Sends a message. The session should be in the Connected state.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="messageType">
//        /// The type of the message body (message or info).
//        /// </param>
//        /// <param name="contentType">
//        /// The content type describing the body. Can be null if body is null and if null text/plain, UTF-8 is assumed.
//        /// </param>
//        /// <param name="body">
//        /// The body for the data.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is in an invalid state to send the message.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when arguments are null.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when EndSendMessage is called multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error. 
//        ///            The SipResponseData in the exception should give additional information.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when some other unknown errors occur.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.ServerPolicyException">
//        /// A server policy setting does not allow the sending of the message.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendMessageAsync(this Microsoft.Rtc.Signaling.SignalingSession source, Microsoft.Rtc.Signaling.MessageType messageType, System.Net.Mime.ContentType contentType, byte[] body)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendMessage, source.EndSendMessage, messageType, contentType, body, null);
//        }
        
//        /// <summary>
//        /// Sends a provisional response.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The redirection response code to use.
//        /// </param>
//        /// <returns>
//        /// Returns the PRACK message data, if the inviter supports reliable response.
//        /// Can be null if the inviter does not support reliable response.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the session does not allow the operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> SendProvisionalResponseAsync(this Microsoft.Rtc.Signaling.SignalingSession source, int responseCode)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginSendProvisionalResponse, source.EndSendProvisionalResponse, responseCode, null);
//        }
        
//        /// <summary>
//        /// Sends a provisional response.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The redirection response code to use.
//        /// </param>
//        /// <param name="options">
//        /// Optional parameters to specify how the provisional
//        ///            response should be sent.
//        /// </param>
//        /// <returns>
//        /// Returns the PRACK message data, if the inviter supports reliable response.
//        /// Can be null if the inviter does not support reliable response.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the state of the session does not allow the operation or the dialog context
//        ///            has been used in a previous transaction.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData> SendProvisionalResponseAsync(this Microsoft.Rtc.Signaling.SignalingSession source, int responseCode, Microsoft.Rtc.Signaling.SendProvisionalResponseOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipMessageData>.Factory.FromAsync(source.BeginSendProvisionalResponse, source.EndSendProvisionalResponse, responseCode, options, null);
//        }
        
//        /// <summary>
//        /// This method can be used to send a reliable provisional response with option to send answer for early media. If the inviter supports 100rel and
//        /// the local policy is not unsupported, this method will wait for the PRACK. Otherwise, this method will not require 100rel. Any application
//        /// that supports 100rel is recommended to use this method for sending provisional response. SendProvisional method can be used only when the
//        /// application knows for sure that the remote does not require 100rel.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The provisonal response code in the range 101-199.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The custom signaling headers to add the response. Can be null.
//        /// </param>
//        /// <param name="needEarlyMediaSupport">
//        /// The bool indicating whether the provisional response need to send media description.
//        /// </param>
//        /// <returns>
//        /// Returns the PRACK message data, if the inviter supports reliable response.
//        /// Can be null if the inviter does not support reliable response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the response code is not a provisional response code.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if the session is not in incoming state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when SendProvisionalResponse is called multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData> SendReliableProvisionalResponseAsync(this Microsoft.Rtc.Signaling.SignalingSession source, int responseCode, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders, bool needEarlyMediaSupport)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData>.Factory.FromAsync(source.BeginSendReliableProvisionalResponse, source.EndSendReliableProvisionalResponse, responseCode, signalingHeaders, needEarlyMediaSupport, null);
//        }
        
//        /// <summary>
//        /// This method can be used to send a reliable provisional response with option to send answer for early media. If the inviter supports 100rel and
//        /// the local policy is not unsupported, this method will wait for the PRACK. Otherwise, this method will not require 100rel. Any application
//        /// that supports 100rel is recommended to use this method for sending provisional response. SendProvisional method can be used only when the
//        /// application knows for sure that the remote does not require 100rel.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The provisional response code in the range 101-199.
//        /// </param>
//        /// <param name="responseText">
//        /// Reason phrase send out with the response. If null or empty default reason phrase will be generated.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The custom signaling headers to add the response. Can be null.
//        /// </param>
//        /// <param name="needEarlyMediaSupport">
//        /// The flag indicating whether the provisional response need to send media description.
//        /// </param>
//        /// <returns>
//        /// Returns the PRACK message data, if the inviter supports reliable response.
//        /// Can be null if the inviter does not support reliable response.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentOutOfRangeException">
//        /// Thrown when the response code is not a provisional response code.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if the sesssion is not in incoming state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when SendProvisionalResponse is called multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when invalid arguments are passed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument. The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData> SendReliableProvisionalResponseAsync(this Microsoft.Rtc.Signaling.SignalingSession source, int responseCode, string responseText, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders, bool needEarlyMediaSupport)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipRequestData>.Factory.FromAsync(source.BeginSendReliableProvisionalResponse(responseCode, responseText, signalingHeaders, needEarlyMediaSupport, null, null), source.EndSendReliableProvisionalResponse);
//        }
        
//        /// <summary>
//        /// Terminates the session asynchronously.
//        /// The session will be no longer usable.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Signaling.SignalingSession source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Terminates the session asynchronously.
//        /// The session will be no longer usable.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The collection of signaling headers to attach to any message that is sent. Can be null.
//        /// </param>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Signaling.SignalingSession source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Renegotiates the media description using the UPDATE message.
//        /// Only one negotiation can be outstanding at any time.
//        /// The session should be in the Connected state for this method to work.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="headers">
//        /// A collection of headers to be included in the message.
//        /// </param>
//        /// <remarks>
//        /// This API is not intended for production use. It is useful for testing ony. It does not check properly
//        /// that other INVITEs or UPDATEs are outstanding and throw exceptions in those cases.
//        /// This API is likely to change or be removed without notice.
//        /// </remarks>
//        /// <returns>
//        /// Returns the SIP response data associated with the operation.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the session is not in a valid state to renegotiate.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeInvalidOperationException">
//        /// Thrown when called in a temporary invalid state, and the operation can be retried.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when there is no media description available.
//        /// </exception>
//        /// <exception cref="T:System.Exception">
//        /// Thrown by the application when generating media (interface IOfferAnswer) is not handled by the platform.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task RenegotiateUsingUpdateAsync(this Microsoft.Rtc.Internal.Signaling.SignalingSessionInternal source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> headers)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRenegotiateUsingUpdate, source.EndRenegotiateUsingUpdate, headers, null);
//        }
        
//        /// <summary>
//        /// Starts an asynchronous Register operation for the current endpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// Collection of signaling headers to be included with Register request. Can be null.
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method was not called in the Unregistered state, or the endpoint is terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RegisterException">
//        /// Thrown when the registration failed.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.AuthenticationException">
//        /// Thrown when a general authentication-related problem occurred.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when one of the header in headers parameters is a restricted header.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RegisterException">
//        /// Thrown when the Register operation failed with the message text indicating the reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.AuthenticationException">
//        /// Thrown when a general authentication-related problem occurred.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when server did not respond for Register request.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> RegisterAsync(this Microsoft.Rtc.Signaling.SipEndpoint source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRegister, source.EndRegister, signalingHeaders, null);
//        }
        
//        /// <summary>
//        /// Starts an asynchronous Register operation for the current endpoint.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the method was not called in the Unregistered state, or the endpoint had been terminated.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RegisterException">
//        /// Thrown when the Register operation failed with the message text indicating the reason.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.AuthenticationException">
//        /// Thrown when a general authentication-related problem occurred.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when server did not respond for Register request.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> RegisterAsync(this Microsoft.Rtc.Signaling.SipEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginRegister, source.EndRegister, null);
//        }
        
//        /// <summary>
//        /// Starts an asynchronous process to unregister the current endpoint.
//        /// This method always succeeds.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> UnregisterAsync(this Microsoft.Rtc.Signaling.SipEndpoint source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginUnregister, source.EndUnregister, null);
//        }
        
//        /// <summary>
//        /// Sends a message.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="localIdentityUri">
//        /// The local identify URI to use. If null, local endpoint's URI is used.
//        /// </param>
//        /// <param name="messageType">
//        /// The message type.
//        /// </param>
//        /// <param name="sessionTarget">
//        /// Target to send the message.
//        /// </param>
//        /// <param name="contentType">
//        /// Content type describing the body. If null text/plain, UTF-8 is assumed.
//        /// </param>
//        /// <param name="body">
//        /// The body for the data.
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// The headers provided for this invite. Can be null.
//        /// </param>
//        /// <returns>
//        /// The response data.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when null is supplied for a required argument.  The argument name which is required is 
//        ///            is part of the exception message.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown if one of the SignalingHeader in signalingHeaders collection have null or restricted header.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the server or remote participant returns an error.  The response code in
//        ///            the exception should give more information about the error.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> SendMessageAsync(this Microsoft.Rtc.Signaling.SipPeerToPeerEndpoint source, string localIdentityUri, Microsoft.Rtc.Signaling.MessageType messageType, Microsoft.Rtc.Signaling.RealTimeAddress sessionTarget, System.Net.Mime.ContentType contentType, byte[] body, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginSendMessage(localIdentityUri, messageType, sessionTarget, contentType, body, signalingHeaders, null, null), source.EndSendMessage);
//        }
        
//        /// <summary>
//        /// Initiates a service request.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> ServiceAsync(this Microsoft.Rtc.Signaling.SipServiceRequest source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginService, source.EndService, null);
//        }
        
//        /// <summary>
//        /// Initiates a service request.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="target">
//        /// The address to be used in "To" header of the service request.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> ServiceAsync(this Microsoft.Rtc.Signaling.SipServiceRequest source, Microsoft.Rtc.Signaling.RealTimeAddress target)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginService, source.EndService, target, null);
//        }
        
//        /// <summary>
//        /// Initiates a service request.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="signalingHeaders">
//        /// "Accepted" headers that you may want to add in the service request. Can be null.
//        /// </param>
//        /// <param name="target">
//        /// The address to be used in "To" header of the service request.
//        /// </param>
//        /// <returns>
//        /// Returns the response data.
//        /// </returns>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when the this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData> ServiceAsync(this Microsoft.Rtc.Signaling.SipServiceRequest source, System.Collections.Generic.IEnumerable<Microsoft.Rtc.Signaling.SignalingHeader> signalingHeaders, Microsoft.Rtc.Signaling.RealTimeAddress target)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Signaling.SipResponseData>.Factory.FromAsync(source.BeginService, source.EndService, signalingHeaders, target, null);
//        }
        
//        /// <summary>
//        /// Creates a transaction async result to refresh an existing subscription and puts the workitem in queue.
//        /// Refresh is allowed only if the current subscription state is valid.
//        /// Multiple simultaneous refreshes are allowed, but not recommended for the application.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the current subscription signaling state is not Subscribed.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the parameter is null. The IAsyncResult is a required parameter.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the IAsyncResult object is created by a Begin method for a different operation
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when End is called multiple times.
//        /// </exception>
//        public static System.Threading.Tasks.Task RefreshAsync(this Microsoft.Rtc.Signaling.SipSubscription source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginRefresh, source.EndRefresh, null);
//        }
        
//        /// <summary>
//        /// Send an update message on existing subscription dialog, this is useful where server allows the change in the semantics of existing subscription
//        /// dialog especially used for LS batch subscriptions.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="contentType">
//        /// The content type to send with the update message.
//        /// </param>
//        /// <param name="messageBody">
//        /// The message body to send with the update message
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is terminating.
//        /// </exception>
//        public static System.Threading.Tasks.Task SendUpdateMessageAsync(this Microsoft.Rtc.Signaling.SipSubscription source, System.Net.Mime.ContentType contentType, byte[] messageBody)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSendUpdateMessage, source.EndSendUpdateMessage, contentType, messageBody, null);
//        }
        
//        /// <summary>
//        /// Creates an subscribe request body and puts the workItem in queue to invoke Subscribe.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// Multiple subscription for the event "vnd-microsoft-roaming-self" are not allowed from same endpoint, so establishing another subscription session for this event will cause InvalidOperationException.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the Subscribe/BeginSubscribe operation to this SipSubscription had already been called.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is terminating.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown if event package is "vnd-microsoft-roaming-self" and RealTimeEndpoint already have a subscription for this event.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the parameter was null. The IAsyncResult is a required parameter.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the IAsyncResult object was created by a Begin method for a different operation.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when End was called multiple times.
//        /// </exception>
//        public static System.Threading.Tasks.Task SubscribeAsync(this Microsoft.Rtc.Signaling.SipSubscription source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginSubscribe, source.EndSubscribe, null);
//        }
        
//        /// <summary>
//        /// If a subscription exists, then terminate the subscription; else completed as no operation.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the parameter is null. The IAsyncResult is a required parameter.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the IAsyncResult object is created by a Begin method for a different operation
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when End was called multiple times.
//        /// </exception>
//        public static System.Threading.Tasks.Task TerminateAsync(this Microsoft.Rtc.Signaling.SipSubscription source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginTerminate, source.EndTerminate, null);
//        }
        
//        /// <summary>
//        /// Not supported.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="buffer">
//        /// Not supported.
//        /// </param>
//        /// <param name="offset">
//        /// Not supported.
//        /// </param>
//        /// <param name="count">
//        /// Not supported.
//        /// </param>
//        /// <returns>
//        /// Not supported.
//        /// </returns>
//        public static System.Threading.Tasks.Task<int> ReadAsync(this Microsoft.Rtc.Collaboration.AudioVideo.SpeechRecognitionStream source, byte[] buffer, int offset, int count)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<int>.Factory.FromAsync(source.BeginRead, source.EndRead, buffer, offset, count, null);
//        }
        
//        /// <summary>
//        /// Not supported.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="buffer">
//        /// Not supported.
//        /// </param>
//        /// <param name="offset">
//        /// Not supported.
//        /// </param>
//        /// <param name="count">
//        /// Not supported.
//        /// </param>
//        public static System.Threading.Tasks.Task WriteAsync(this Microsoft.Rtc.Collaboration.AudioVideo.SpeechRecognitionStream source, byte[] buffer, int offset, int count)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginWrite, source.EndWrite, buffer, offset, count, null);
//        }
        
//        /// <summary>
//        /// Not supported.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="buffer">
//        /// Not applicable.
//        /// </param>
//        /// <param name="offset">
//        /// Not applicable.
//        /// </param>
//        /// <param name="count">
//        /// Not applicable.
//        /// </param>
//        /// <returns>
//        /// Not applicable.
//        /// </returns>
//        /// <exception cref="T:System.NotSupportedException">
//        /// Thrown when this method is called.
//        /// </exception>
//        /// <exception cref="T:System.NotSupportedException">
//        /// Thrown when this method is called.
//        /// </exception>
//        public static System.Threading.Tasks.Task<int> ReadAsync(this Microsoft.Rtc.Collaboration.AudioVideo.SpeechSynthesisConnector source, byte[] buffer, int offset, int count)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<int>.Factory.FromAsync(source.BeginRead, source.EndRead, buffer, offset, count, null);
//        }
        
//        /// <summary>
//        /// Not supported.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="buffer">
//        /// Not applicable.
//        /// </param>
//        /// <param name="offset">
//        /// Not applicable.
//        /// </param>
//        /// <param name="count">
//        /// Not applicable.
//        /// </param>
//        /// <exception cref="T:System.NotSupportedException">
//        /// Thrown when this method is called.
//        /// </exception>
//        /// <exception cref="T:System.NotSupportedException">
//        /// Thrown when this method is called.
//        /// </exception>
//        public static System.Threading.Tasks.Task WriteAsync(this Microsoft.Rtc.Collaboration.AudioVideo.SpeechSynthesisConnector source, byte[] buffer, int offset, int count)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginWrite, source.EndWrite, buffer, offset, count, null);
//        }
        
//        /// <summary>
//        /// Accepts the initial incoming session, or any refresh request received.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="options">
//        /// Options to modify accept behavior.
//        /// </param>
//        public static System.Threading.Tasks.Task AcceptAsync(this Microsoft.Rtc.Internal.Signaling.SubscriptionRefreshReceivedEventArgs source, Microsoft.Rtc.Internal.Signaling.SubscriptionSessionAcceptOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginAccept, source.EndAccept, options, null);
//        }
        
//        /// <summary>
//        /// Declines the incoming session, or any refresh that is received.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="responseCode">
//        /// The final response code to send.
//        /// </param>
//        /// <param name="options">
//        /// 
//        /// </param>
//        public static System.Threading.Tasks.Task DeclineAsync(this Microsoft.Rtc.Internal.Signaling.SubscriptionRefreshReceivedEventArgs source, int responseCode, Microsoft.Rtc.Internal.Signaling.SubscriptionSessionDeclineOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDecline, source.EndDecline, responseCode, options, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to delete all maunally published User presence states.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <remarks>
//        /// User PresenceState is typically published by the client, when user manually set the PresenceState in UI.
//        /// This method allows application to delete all manual user PresenceState publication and reset the presence state
//        /// to depend only on application's automatic presence state publications.
//        /// </remarks>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task DeleteUserPresenceStateAsync(this Microsoft.Rtc.Collaboration.UserEndpointPresenceServices source)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginDeleteUserPresenceState, source.EndDeleteUserPresenceState, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to publish the user or endpoint presence state.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="newState">
//        /// New user state for the endpoint, must be of type  or .
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in the "registered" state, or the current state of  is not "subscribed".
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when  passed is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when  is not of type 
//        ///            or .
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdatePresenceStateAsync(this Microsoft.Rtc.Collaboration.UserEndpointPresenceServices source, Microsoft.Rtc.Collaboration.Presence.PresenceState newState)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdatePresenceState, source.EndUpdatePresenceState, newState, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to set the local owner preferred privacy mode.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not a user endpoint or subscribed to this session.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the argument passed is null or invalid.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same result.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.PublishSubscribeException">
//        /// Thrown when the SIP SERVICE request is rejected by the server.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when the underlying subscription changed during the publish operation or an empty container update operation is specified.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when SIP Transport, SIP authentication and credential-related errors are encountered.
//        /// </exception>
//        public static System.Threading.Tasks.Task UpdatePrivacyPreferenceAsync(this Microsoft.Rtc.Collaboration.UserEndpointPresenceServices source, Microsoft.Rtc.Collaboration.Presence.PrivacyModePreference privacyPreference)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task.Factory.FromAsync(source.BeginUpdatePrivacyPreference, source.EndUpdatePrivacyPreference, privacyPreference, null);
//        }
        
//        /// <summary>
//        /// Begins an asynchronous operation to set a new  pin.
//        /// </summary>
//        /// <param name="source">
//        /// The source object
//        /// </param>
//        /// <param name="newPin">
//        /// New pin to be set. Cannot be null or empty.
//        /// </param>
//        /// <param name="options">
//        /// The optional parameters to be used when setting new pin.
//        /// </param>
//        /// <returns>
//        /// Returns pin owner details.
//        /// </returns>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the
//        ///             parameter is null or empty.
//        ///             parameter contains invalid or restricted signaling headers.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when the endpoint is not in valid state to perform this operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Collaboration.PinManagement.PinFailureException">
//        /// Thrown when the pin verification for the given uri failed. Applications can use the Reason property to get the failure reason.
//        /// </exception>
//        /// <exception cref="T:System.InvalidOperationException">
//        /// Thrown when this method is invoked multiple times using the same asyncResult.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentNullException">
//        /// Thrown when the  parameter is null.
//        /// </exception>
//        /// <exception cref="T:System.ArgumentException">
//        /// Thrown when the  parameter is invalid.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.FailureResponseException">
//        /// Thrown when the remote side returns a failure response for the establish request operation.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationTimeoutException">
//        /// Thrown when this operation timed out.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.OperationFailureException">
//        /// Thrown when any of the sub operations of this operation failed due to invalid object state.
//        /// </exception>
//        /// <exception cref="T:Microsoft.Rtc.Signaling.RealTimeException">
//        /// Thrown when any of the sub operations of this operation failed due to SIP related errors like connection failure, Authentication failure.
//        /// </exception>
//        public static System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.PinManagement.UpdatePinResult> UpdatePinAsync(this Microsoft.Rtc.Collaboration.PinManagement.UserPinServices source, string newPin, Microsoft.Rtc.Collaboration.PinManagement.UpdatePinOptions options)
//        {
//            if ((source == null))
//            {
//                throw new System.ArgumentNullException("source");
//            }
//            return System.Threading.Tasks.Task<Microsoft.Rtc.Collaboration.PinManagement.UpdatePinResult>.Factory.FromAsync(source.BeginUpdatePin, source.EndUpdatePin, newPin, options, null);
//        }
//    }
//}
